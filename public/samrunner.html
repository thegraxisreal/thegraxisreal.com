<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sam Jumper</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            margin: 0;
            background-color: #87CEEB;
            overflow: hidden;
        }
        /* Parallax background layers */
        .parallax-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-repeat: repeat-x;
            background-size: auto 100%;
        }
        #backgroundFar {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="600" viewBox="0 0 1000 600"><path d="M0,150 L100,120 L200,170 L300,110 L400,160 L500,130 L600,175 L700,115 L800,165 L900,125 L1000,150 L1000,600 L0,600 Z" fill="%23729FCF"/></svg>');
            z-index: 1;
        }
        #backgroundMid {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="600" viewBox="0 0 1200 600"><path d="M0,200 L150,170 L300,220 L450,170 L600,230 L750,180 L900,240 L1050,190 L1200,210 L1200,600 L0,600 Z" fill="%235C95CF"/></svg>');
            z-index: 2;
        }
        #backgroundClose {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1500" height="600" viewBox="0 0 1500 600"><path d="M0,250 L150,220 L300,270 L450,230 L600,280 L750,240 L900,290 L1050,250 L1200,300 L1350,260 L1500,280 L1500,600 L0,600 Z" fill="%23356AA0"/></svg>');
            z-index: 3;
        }
        /* Weather effects container */
        #weatherEffects {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            overflow: hidden;
        }
        .raindrop {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.7);
            width: 2px;
            height: 15px;
            transform: rotate(10deg);
        }
        .snowflake {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            width: 5px;
            height: 5px;
            opacity: 0.8;
        }
        #homeScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #4169E1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #homeScreen h1 {
            color: #FFD700;
            font-size: 48px;
            text-shadow: 3px 3px 0 #000;
            margin-bottom: 20px;
        }
        #characterSelector {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            width: 100%;
        }
        .character {
            width: 120px;
            height: 180px;
            margin: 0 15px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }
        .character.selected {
            box-shadow: 0 0 15px 5px #FFD700;
            transform: scale(1.05);
        }
        .character:hover:not(.locked) {
            transform: scale(1.05);
        }
        .character.locked {
            filter: grayscale(100%);
            cursor: not-allowed;
        }
        .character-icon {
            width: 80px;
            height: 80px;
            margin-top: 15px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: white;
        }
        .sam-icon {
            background-color: #FF6347;
        }
        .piper-icon {
            background-color: #333;
        }
        .link-icon {
            background-color: #32CD32;
        }
        .character-name {
            margin-top: 10px;
            font-weight: bold;
            color: #333;
        }
        .character-ability {
            font-size: 12px;
            color: #555;
            text-align: center;
            padding: 0 5px;
            margin-top: 5px;
        }
        .locked-message {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 12px;
            padding: 5px 0;
            text-align: center;
        }
        #startButton {
            background-color: #32CD32;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 0 #228B22;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        #startButton:hover {
            transform: translateY(2px);
            box-shadow: 0 3px 0 #228B22;
        }
        #startButton:active {
            transform: translateY(5px);
            box-shadow: none;
        }
        #gameOverScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #gameOverScreen h2 {
            color: #FF4500;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #finalScore {
            color: white;
            font-size: 32px;
            margin-bottom: 30px;
        }
        #newHighScore {
            color: #FFD700;
            font-size: 24px;
            margin-bottom: 10px;
            display: none;
        }
        #unlockMessage {
            color: #32CD32;
            font-size: 20px;
            margin-bottom: 20px;
            display: none;
        }
        #restartButton {
            background-color: #4169E1;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
        }
        /* Player (original style) */
        #player {
            position: absolute;
            width: 40px;
            height: 60px;
            background-color: #FF6347;
            border-radius: 5px;
            border-bottom: 3px solid #B22222;
            transition: transform 0.1s;
            z-index: 5;
        }
        /* Platform varieties */
        .platform {
            position: absolute;
            border-top: 5px solid #A0522D;
            z-index: 4;
        }
        .platform-normal {
            background-color: #8B4513;
        }
        .platform-grass {
            background-color: #228B22;
            border-top-color: #32CD32;
        }
        .platform-stone {
            background-color: #808080;
            border-top-color: #A9A9A9;
        }
        .platform-ice {
            background-color: #B0E0E6;
            border-top-color: #F0FFFF;
        }
        .spike {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid #FF0000;
            z-index: 5;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 6;
        }
        #highScore {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 18px;
            color: #FFD700;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 6;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 16px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 6;
        }
        #currentCharacter {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 6;
        }
        /* Weather toggle */
        #weatherToggle {
            position: absolute;
            top: 60px;
            left: 20px;
            font-size: 16px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 6;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Parallax Backgrounds -->
        <div id="backgroundFar" class="parallax-layer"></div>
        <div id="backgroundMid" class="parallax-layer"></div>
        <div id="backgroundClose" class="parallax-layer"></div>
        
        <!-- Weather Effects Container -->
        <div id="weatherEffects"></div>
        
        <div id="homeScreen">
            <h1>SAM JUMPER</h1>
            <div style="color: white; font-size: 18px; margin-bottom: 20px;">Public Beta 1.0</div>
            <div id="characterSelector">
                <div class="character selected" data-character="sam">
                    <div class="character-icon sam-icon">S</div>
                    <div class="character-name">Sam</div>
                    <div class="character-ability">Balanced jumper</div>
                </div>
                <div class="character locked" data-character="piper">
                    <div class="character-icon piper-icon">P</div>
                    <div class="character-name">Piper</div>
                    <div class="character-ability">Double jump</div>
                    <div class="locked-message">Unlocks at 100 points</div>
                </div>
                <div class="character locked" data-character="link">
                    <div class="character-icon link-icon">L</div>
                    <div class="character-name">Ling Link</div>
                    <div class="character-ability">Super speed</div>
                    <div class="locked-message">Unlocks at 100 points</div>
                </div>
            </div>
            <button id="startButton">START GAME</button>
        </div>
        <div id="gameOverScreen">
            <h2>GAME OVER</h2>
            <div id="finalScore">Score: 0</div>
            <div id="newHighScore">NEW HIGH SCORE!</div>
            <div id="unlockMessage">New character unlocked!</div>
            <button id="restartButton">PLAY AGAIN</button>
        </div>
        
        <!-- Original player (no animation elements) -->
        <div id="player"></div>
        
        <div id="score">Score: 0</div>
        <div id="highScore">High Score: 0</div>
        <div id="currentCharacter">Character: Sam</div>
        <div id="controls">Controls: Arrow Keys to move, Space or Up Arrow to jump (Press twice for double jump with Piper)</div>
        <div id="weatherToggle">Toggle Weather: Off</div>
    </div>

    <script>
        // Game variables
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('gameContainer');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const currentCharacterDisplay = document.getElementById('currentCharacter');
        const homeScreen = document.getElementById('homeScreen');
        const startButton = document.getElementById('startButton');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const newHighScoreDisplay = document.getElementById('newHighScore');
        const unlockMessageDisplay = document.getElementById('unlockMessage');
        const restartButton = document.getElementById('restartButton');
        const characterElements = document.querySelectorAll('.character');
        const weatherToggle = document.getElementById('weatherToggle');
        const weatherEffects = document.getElementById('weatherEffects');
        
        // Parallax background elements
        const backgroundFar = document.getElementById('backgroundFar');
        const backgroundMid = document.getElementById('backgroundMid');
        const backgroundClose = document.getElementById('backgroundClose');
        
        // Game state
        let containerWidth = window.innerWidth;
        let containerHeight = window.innerHeight;
        let platforms = [];
        let spikes = [];
        let score = 0;
        let highScore = 0;
        let gameRunning = false;
        let playerX = 50;
        let playerY = 0;
        let playerVelX = 0;
        let playerVelY = 0;
        let playerSpeed = 5;
        let jumpForce = 15;
        let gravity = 0.6;
        let isJumping = false;
        let canDoubleJump = false;
        let hasDoubleJumped = false;
        let isGrounded = false;
        let keys = {};
        let jumpKeyPressed = false;
        let jumpKeyWasPressed = false;
        let cameraOffset = 0;
        let platformsGenerated = 0;
        
        // Weather animation variables (no character animations)
        let weatherUpdateTimer = 0;
        
        // Weather variables
        let weatherMode = 'none'; // 'none', 'rain', 'snow'
        let weatherParticles = [];
        
        // Character configuration (original without animation properties)
        const characters = {
            sam: {
                color: '#FF6347',
                borderColor: '#B22222',
                speed: 5,
                jumpForce: 15,
                doubleJump: false,
                unlocked: true
            },
            piper: {
                color: '#333',
                borderColor: '#000',
                speed: 5,
                jumpForce: 13,
                doubleJump: true,
                unlocked: false
            },
            link: {
                color: '#32CD32',
                borderColor: '#228B22',
                speed: 8,
                jumpForce: 15,
                doubleJump: false,
                unlocked: false
            }
        };
        
        let currentCharacter = 'sam';
        
        // Platform types
        const platformTypes = [
            {
                name: 'normal',
                className: 'platform-normal',
                friction: 1.0
            },
            {
                name: 'grass',
                className: 'platform-grass',
                friction: 1.0
            },
            {
                name: 'stone',
                className: 'platform-stone',
                friction: 1.0
            },
            {
                name: 'ice',
                className: 'platform-ice',
                friction: 0.95 // Slippery
            }
        ];
        
        // Initialize player (original style)
        function initPlayer() {
            playerX = 50;
            playerY = 340; // Position player directly above the starting platform
            playerVelX = 0;
            playerVelY = 0;
            isJumping = false;
            hasDoubleJumped = false;
            isGrounded = true; // Start as grounded
            
            // Apply character properties
            playerSpeed = characters[currentCharacter].speed;
            jumpForce = characters[currentCharacter].jumpForce;
            canDoubleJump = characters[currentCharacter].doubleJump;
            
            // Update player appearance
            player.style.backgroundColor = characters[currentCharacter].color;
            player.style.borderBottom = `3px solid ${characters[currentCharacter].borderColor}`;
            
            // Update character display
            currentCharacterDisplay.textContent = `Character: ${currentCharacter.charAt(0).toUpperCase() + currentCharacter.slice(1)}`;
            
            updatePlayerPosition();
        }
        
        // Update player position
        function updatePlayerPosition() {
            player.style.left = (playerX - cameraOffset) + 'px';
            player.style.top = playerY + 'px';
            
            // Add a little tilt based on velocity (from original game)
            if (playerVelX > 0) {
                player.style.transform = 'rotate(5deg)';
            } else if (playerVelX < 0) {
                player.style.transform = 'rotate(-5deg)';
            } else {
                player.style.transform = 'rotate(0)';
            }
        }
        
        // Create platform
        function createPlatform(x, y, width) {
            const platform = document.createElement('div');
            platform.className = 'platform';
            
            // Select a random platform type, weighted towards normal platforms
            const platformTypeIndex = Math.random() < 0.7 ? 0 : Math.floor(Math.random() * platformTypes.length);
            const platformType = platformTypes[platformTypeIndex];
            
            platform.classList.add(platformType.className);
            platform.style.left = (x - cameraOffset) + 'px';
            platform.style.top = y + 'px';
            platform.style.width = width + 'px';
            platform.style.height = '15px';
            
            // Store platform properties
            platform.dataset.origX = x;
            platform.dataset.type = platformType.name;
            platform.dataset.friction = platformType.friction;
            
            gameContainer.appendChild(platform);
            platforms.push(platform);
            platformsGenerated++;
            
            // Randomly add spikes to platforms (but not the first one and after score 20)
            if (platformsGenerated > 1 && Math.random() < 0.25 && score >= 20) {
                // Determine number of spikes (1-3)
                const spikeCount = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < spikeCount; i++) {
                    // Random position along the platform
                    const spikeX = x + (width * Math.random() * 0.8) + (width * 0.1);
                    createSpike(spikeX, y - 16); // Position spike on top of platform
                }
            }
            
            return platform;
        }
        
        // Create spike
        function createSpike(x, y) {
            const spike = document.createElement('div');
            spike.className = 'spike';
            spike.style.left = (x - cameraOffset) + 'px';
            spike.style.top = y + 'px';
            
            // Store the original x position for camera adjustment
            spike.dataset.origX = x;
            
            gameContainer.appendChild(spike);
            spikes.push(spike);
            
            return spike;
        }
        
        // Generate initial platforms
        function generateInitialPlatforms() {
            // Clear existing platforms
            platforms.forEach(platform => {
                gameContainer.removeChild(platform);
            });
            platforms = [];
            
            // Clear existing spikes
            spikes.forEach(spike => {
                gameContainer.removeChild(spike);
            });
            spikes = [];
            
            // Starting platform - make it wider and ensure it's properly positioned
            createPlatform(0, 400, 300);
            
            // Generate some random platforms with better spacing
            let lastX = 250; // Start after the first platform
            for (let i = 0; i < 20; i++) {
                const x = lastX + 50 + Math.random() * 150; // Ensure platforms aren't too far apart
                const y = 300 + Math.random() * 150; // Keep platforms at reasonable heights
                const width = 70 + Math.random() * 130;
                createPlatform(x, y, width);
                lastX = x + width;
            }
        }
        
        // Generate more platforms as player progresses
        function generateMorePlatforms() {
            const lastPlatform = platforms[platforms.length - 1];
            const lastX = parseFloat(lastPlatform.dataset.origX) + parseFloat(lastPlatform.style.width);
            
            if (playerX > lastX - containerWidth) {
                let newLastX = lastX;
                for (let i = 0; i < 5; i++) {
                    const x = newLastX + 50 + Math.random() * 150;
                    const y = 300 + Math.random() * 150;
                    const width = 70 + Math.random() * 130;
                    createPlatform(x, y, width);
                    newLastX = x + width;
                }
            }
        }
        
        // Check collision with platforms and spikes
        function checkCollisions() {
            // Check platform collisions
            isGrounded = false;
            
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                const platformX = parseFloat(platform.dataset.origX);
                const platformY = parseFloat(platform.style.top);
                const platformWidth = parseFloat(platform.style.width);
                const platformFriction = parseFloat(platform.dataset.friction);
                
                // Improved collision detection for platforms
                if (playerVelY >= 0 && 
                    playerY + player.offsetHeight >= platformY - 5 && 
                    playerY + player.offsetHeight <= platformY + 20 &&
                    playerX + player.offsetWidth > platformX && 
                    playerX < platformX + platformWidth) {
                    
                    playerY = platformY - player.offsetHeight;
                    playerVelY = 0;
                    isGrounded = true;
                    isJumping = false;
                    hasDoubleJumped = false; // Reset double jump when landing
                    
                    // Apply platform-specific friction
                    playerVelX *= platformFriction;
                    
                    break;
                }
            }
            
            // Check spike collisions
            for (let i = 0; i < spikes.length; i++) {
                const spike = spikes[i];
                const spikeX = parseFloat(spike.dataset.origX);
                const spikeY = parseFloat(spike.style.top);
                
                // Simple spike collision detection (16x16 pixel area)
                if (playerX + player.offsetWidth > spikeX - 8 && 
                    playerX < spikeX + 8 &&
                    playerY + player.offsetHeight > spikeY &&
                    playerY < spikeY + 16) {
                    
                    // Player hit a spike
                    gameOver();
                    return;
                }
            }
        }
        
        // Update camera position
        function updateCamera() {
            if (playerX > containerWidth / 2) {
                cameraOffset = playerX - containerWidth / 2;
                
                // Update platform positions
                platforms.forEach(platform => {
                    const origX = parseFloat(platform.dataset.origX);
                    platform.style.left = (origX - cameraOffset) + 'px';
                });
                
                // Update spike positions
                spikes.forEach(spike => {
                    const origX = parseFloat(spike.dataset.origX);
                    spike.style.left = (origX - cameraOffset) + 'px';
                });
                
                // Update parallax backgrounds
                backgroundFar.style.backgroundPosition = `${-cameraOffset * 0.2}px 0`;
                backgroundMid.style.backgroundPosition = `${-cameraOffset * 0.4}px 0`;
                backgroundClose.style.backgroundPosition = `${-cameraOffset * 0.6}px 0`;
            }
        }
        
        // Remove platforms and spikes that are far behind
        function removeFarPlatforms() {
            // Remove platforms
            const platformsToRemove = [];
            platforms.forEach((platform, index) => {
                const platformX = parseFloat(platform.dataset.origX);
                if (platformX < cameraOffset - 200) {
                    platformsToRemove.push(index);
                    gameContainer.removeChild(platform);
                }
            });
            
            // Remove from array (from back to front to avoid index issues)
            for (let i = platformsToRemove.length - 1; i >= 0; i--) {
                platforms.splice(platformsToRemove[i], 1);
            }
            
            // Remove spikes
            const spikesToRemove = [];
            spikes.forEach((spike, index) => {
                const spikeX = parseFloat(spike.dataset.origX);
                if (spikeX < cameraOffset - 200) {
                    spikesToRemove.push(index);
                    gameContainer.removeChild(spike);
                }
            });
            
            // Remove from array (from back to front to avoid index issues)
            for (let i = spikesToRemove.length - 1; i >= 0; i--) {
                spikes.splice(spikesToRemove[i], 1);
            }
        }
        
        // Update score based on distance
        function updateScore() {
            score = Math.floor(playerX / 100);
            scoreDisplay.textContent = 'Score: ' + score;
            highScoreDisplay.textContent = 'High Score: ' + highScore;
            
            // Change background based on score
            if (score > 100) {
                // Night mode
                gameContainer.style.backgroundColor = '#191970'; // Midnight blue
                
                // Update parallax background colors for night
                backgroundFar.style.backgroundImage = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="600" viewBox="0 0 1000 600"><path d="M0,150 L100,120 L200,170 L300,110 L400,160 L500,130 L600,175 L700,115 L800,165 L900,125 L1000,150 L1000,600 L0,600 Z" fill="%23729FCF"/></svg>\')';
                backgroundMid.style.backgroundImage = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="600" viewBox="0 0 1200 600"><path d="M0,200 L150,170 L300,220 L450,170 L600,230 L750,180 L900,240 L1050,190 L1200,210 L1200,600 L0,600 Z" fill="%235C95CF"/></svg>\')';
                backgroundClose.style.backgroundImage = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1500" height="600" viewBox="0 0 1500 600"><path d="M0,250 L150,220 L300,270 L450,230 L600,280 L750,240 L900,290 L1050,250 L1200,300 L1350,260 L1500,280 L1500,600 L0,600 Z" fill="%23356AA0"/></svg>\')';
                
                // Remove stars if they exist
                const stars = document.getElementById('stars');
                if (stars) {
                    gameContainer.removeChild(stars);
                }
            }
        }
        
        // Weather system
        function toggleWeather() {
            // Cycle through weather types
            if (weatherMode === 'none') {
                weatherMode = 'rain';
                weatherToggle.textContent = 'Toggle Weather: Rain';
                startWeather();
            } else if (weatherMode === 'rain') {
                weatherMode = 'snow';
                weatherToggle.textContent = 'Toggle Weather: Snow';
                startWeather();
            } else {
                weatherMode = 'none';
                weatherToggle.textContent = 'Toggle Weather: Off';
                clearWeather();
            }
        }
        
        function startWeather() {
            clearWeather();
            
            if (weatherMode === 'rain') {
                // Create raindrops
                for (let i = 0; i < 100; i++) {
                    createRaindrop();
                }
            } else if (weatherMode === 'snow') {
                // Create snowflakes
                for (let i = 0; i < 50; i++) {
                    createSnowflake();
                }
            }
        }
        
        function createRaindrop() {
            const raindrop = document.createElement('div');
            raindrop.className = 'raindrop';
            raindrop.style.left = Math.random() * containerWidth + 'px';
            raindrop.style.top = Math.random() * containerHeight + 'px';
            raindrop.speedY = 15 + Math.random() * 10;
            
            weatherEffects.appendChild(raindrop);
            weatherParticles.push(raindrop);
        }
        
        function createSnowflake() {
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.style.left = Math.random() * containerWidth + 'px';
            snowflake.style.top = Math.random() * containerHeight + 'px';
            snowflake.speedY = 1 + Math.random() * 3;
            snowflake.speedX = Math.random() * 2 - 1;
            snowflake.style.width = (3 + Math.random() * 4) + 'px';
            snowflake.style.height = snowflake.style.width;
            
            weatherEffects.appendChild(snowflake);
            weatherParticles.push(snowflake);
        }
        
        function updateWeather(deltaTime) {
            if (weatherMode === 'none') return;
            
            const particlesToRemove = [];
            
            weatherParticles.forEach((particle, index) => {
                if (weatherMode === 'rain') {
                    // Update raindrop position
                    const newTop = parseFloat(particle.style.top) + particle.speedY * (deltaTime / 16);
                    particle.style.top = newTop + 'px';
                    
                    // Remove if off screen and create a new one
                    if (newTop > containerHeight) {
                        particlesToRemove.push(index);
                    }
                } else if (weatherMode === 'snow') {
                    // Update snowflake position with some wobble
                    const newTop = parseFloat(particle.style.top) + particle.speedY * (deltaTime / 16);
                    let newLeft = parseFloat(particle.style.left) + particle.speedX * (deltaTime / 16);
                    
                    // Add a little wobble
                    particle.speedX += (Math.random() - 0.5) * 0.1;
                    
                    // Keep within bounds
                    if (newLeft < 0) newLeft = containerWidth;
                    if (newLeft > containerWidth) newLeft = 0;
                    
                    particle.style.top = newTop + 'px';
                    particle.style.left = newLeft + 'px';
                    
                    // Remove if off screen and create a new one
                    if (newTop > containerHeight) {
                        particlesToRemove.push(index);
                    }
                }
            });
            
            // Remove particles that are off screen
            for (let i = particlesToRemove.length - 1; i >= 0; i--) {
                const index = particlesToRemove[i];
                weatherEffects.removeChild(weatherParticles[index]);
                weatherParticles.splice(index, 1);
                
                // Create a new particle at the top
                if (weatherMode === 'rain') {
                    createRaindrop();
                } else if (weatherMode === 'snow') {
                    createSnowflake();
                }
            }
        }
        
        function clearWeather() {
            // Remove all weather particles
            weatherParticles.forEach(particle => {
                weatherEffects.removeChild(particle);
            });
            weatherParticles = [];
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            
            // Check for high score
            let isNewHighScore = false;
            if (score > highScore) {
                highScore = score;
                isNewHighScore = true;
                newHighScoreDisplay.style.display = 'block';
            } else {
                newHighScoreDisplay.style.display = 'none';
            }
            
            // Check for character unlocks
            let newUnlock = false;
            if (highScore >= 100) {
                if (!characters.piper.unlocked) {
                    characters.piper.unlocked = true;
                    newUnlock = true;
                    unlockMessageDisplay.textContent = "Piper unlocked!";
                    document.querySelector('[data-character="piper"]').classList.remove('locked');
                }
                
                if (!characters.link.unlocked) {
                    characters.link.unlocked = true;
                    newUnlock = true;
                    unlockMessageDisplay.textContent = "Ling Link unlocked!";
                    document.querySelector('[data-character="link"]').classList.remove('locked');
                }
            }
            
            if (newUnlock) {
                unlockMessageDisplay.style.display = 'block';
            } else {
                unlockMessageDisplay.style.display = 'none';
            }
            
            // Update displays
            gameOverScreen.style.display = 'flex';
            finalScoreDisplay.textContent = 'Score: ' + score;
            highScoreDisplay.textContent = 'High Score: ' + highScore;
        }
        
        // Game loop (using original physics)
        function gameLoop() {
            if (!gameRunning) return;
            
            // Apply gravity (original fixed value)
            playerVelY += gravity;
            
            // Apply horizontal movement based on key input
            if (keys.ArrowLeft) {
                playerVelX = -playerSpeed;
            } else if (keys.ArrowRight) {
                playerVelX = playerSpeed;
            } else {
                // Add some friction
                playerVelX *= 0.9;
            }
            
            // Handle jumping logic
            jumpKeyPressed = keys[' '] || keys.ArrowUp;
            
            // Regular jump
            if (jumpKeyPressed && !jumpKeyWasPressed && isGrounded) {
                playerVelY = -jumpForce;
                isJumping = true;
                isGrounded = false;
                hasDoubleJumped = false;
            }
            // Double jump functionality for Piper
            else if (jumpKeyPressed && !jumpKeyWasPressed && !isGrounded && canDoubleJump && !hasDoubleJumped) {
                playerVelY = -jumpForce * 0.8; // Slightly weaker double jump
                hasDoubleJumped = true;
            }
            
            // Update jump key state
            jumpKeyWasPressed = jumpKeyPressed;
            
            // Apply velocities (original fixed values)
            playerX += playerVelX;
            playerY += playerVelY;
            
            // Limit player from going too far left
            if (playerX < 0) {
                playerX = 0;
                playerVelX = 0;
            }
            
            // Check for bottom of screen (game over)
            if (playerY > containerHeight) {
                gameOver();
                return;
            }
            
            // Check platform and spike collisions
            checkCollisions();
            
            // If game is no longer running (player hit a spike), exit the loop
            if (!gameRunning) return;
            
            // Update camera position
            updateCamera();
            
            // Generate more platforms
            generateMorePlatforms();
            
            // Remove far behind platforms and spikes
            removeFarPlatforms();
            
            // Update score
            updateScore();
            
            // Update player position
            updatePlayerPosition();
            
            // Update weather effects
            updateWeather(16); // Fixed timestep for weather
            
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Character selection
        function selectCharacter(character) {
            if (characters[character].unlocked) {
                currentCharacter = character;
                
                // Update selection UI
                characterElements.forEach(el => {
                    if (el.dataset.character === character) {
                        el.classList.add('selected');
                    } else {
                        el.classList.remove('selected');
                    }
                });
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', function(e) {
            keys[e.key] = true;
        });
        
        document.addEventListener('keyup', function(e) {
            keys[e.key] = false;
        });
        
        // Character selection event listeners
        characterElements.forEach(el => {
            el.addEventListener('click', function() {
                const character = this.dataset.character;
                if (characters[character].unlocked) {
                    selectCharacter(character);
                }
            });
        });
        
        // Weather toggle event listener
        weatherToggle.addEventListener('click', toggleWeather);
        
        startButton.addEventListener('click', function() {
            homeScreen.style.display = 'none';
            score = 0;
            cameraOffset = 0;
            platformsGenerated = 0;
            
            // Clear any existing spikes
            spikes.forEach(spike => {
                gameContainer.removeChild(spike);
            });
            spikes = [];
            
            updateScore();
            initPlayer();
            generateInitialPlatforms();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        });
        
        restartButton.addEventListener('click', function() {
            gameOverScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
        });
        
        // Handle window resize
        function handleResize() {
            containerWidth = window.innerWidth;
            containerHeight = window.innerHeight;
        }
        
        // Listen for window resize
        window.addEventListener('resize', handleResize);
        
        // Initialize the game
        window.addEventListener('load', function() {
            handleResize();
            initPlayer();
            highScoreDisplay.textContent = 'High Score: ' + highScore;
        });
    </script>
</body>
</html><path d="M0,150 L100,120 L200,170 L300,110 L400,160 L500,130 L600,175 L700,115 L800,165 L900,125 L1000,150 L1000,600 L0,600 Z" fill="%23000033"/></svg>\')';
                backgroundMid.style.backgroundImage = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="600" viewBox="0 0 1200 600"><path d="M0,200 L150,170 L300,220 L450,170 L600,230 L750,180 L900,240 L1050,190 L1200,210 L1200,600 L0,600 Z" fill="%23000066"/></svg>\')';
                backgroundClose.style.backgroundImage = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1500" height="600" viewBox="0 0 1500 600"><path d="M0,250 L150,220 L300,270 L450,230 L600,280 L750,240 L900,290 L1050,250 L1200,300 L1350,260 L1500,280 L1500,600 L0,600 Z" fill="%23000099"/></svg>\')';
                
                // Add stars to the background
                if (!document.getElementById('stars')) {
                    const stars = document.createElement('div');
                    stars.id = 'stars';
                    stars.style.position = 'absolute';
                    stars.style.top = '0';
                    stars.style.left = '0';
                    stars.style.width = '100%';
                    stars.style.height = '100%';
                    stars.style.backgroundImage = 'radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 8px)';
                    stars.style.backgroundSize = '100px 100px';
                    stars.style.zIndex = '0';
                    gameContainer.insertBefore(stars, backgroundFar);
                }
            } else {
                // Day mode
                gameContainer.style.backgroundColor = '#87CEEB'; // Sky blue (day)
                
                // Update parallax background colors for day
                backgroundFar.style.backgroundImage = 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="600" viewBox="0 0 1000 600">
