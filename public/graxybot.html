<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graxybot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbIOIEHD8HBxe7+rzMGGEAPseCS6VVuLESXNKRsQXHHMxJx/g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
/* --- Base Styles and Variables --- */
:root {
    --primary: #5e60ce;
    --primary-light: #787ae0; /* Lighter shade for hover */
    --primary-active: #4a4cc2; /* Darker shade for active/reason */
    --max-color: #b741d1; /* Color for Max features */
    --max-bg: #f3e8ff; /* Light background for Max modal */
    --unhinged-color: #d9534f; /* Color for Unhinged model */
    --background: #ffffff;
    --background-secondary: #f7f7f8; /* Chat area bg */
    --sidebar-bg: #ececf1; /* Sidebar background */
    --text-primary: #202123;
    --text-secondary: #6e6e80;
    --border-color: #d1d1db; /* Slightly darker border */
    --input-bg: #ffffff;
    --input-border: #d1d1db;
    --user-message-bg: #e9eaf6;
    --bot-message-bg: #ffffff; /* Bot messages on light gray bg */
    --error-bg: #f8d7da;
    --error-text: #721c24;
    --error-border: #f5c6cb;
    --hover-bg: #e0e0e6; /* Hover background for sidebar items */
    --title-font: 'Poppins', sans-serif;
    --transition: all 0.2s ease;
    --sidebar-width: 260px;
    --code-bg: #272822; /* Default dark background for code */
    --code-header-bg: #3a3b35;
    --code-text-color: #f8f8f2;
    --code-button-bg: #4a4b45;
    --code-button-hover-bg: #5a5b55;
    --reason-button-bg: #f0f0f0;
    --reason-button-border: #d1d1db;
    --reason-button-text: #555;
    --reason-button-hover-bg: #e5e5e5;
    --reason-button-active-bg: var(--primary);
    --reason-button-active-border: var(--primary-active);
    --reason-button-active-text: white;
    --image-preview-border: #ccc;
    --image-remove-bg: rgba(0, 0, 0, 0.5);
    --image-remove-text: white;
    --notification-bg: #e9eaf6; /* Similar to user message */
    --notification-text: #444;
    --prompt-button-bg: #f0f0f0;
    --prompt-button-hover-bg: #e5e5e5;
    --prompt-button-border: #d1d1db;
    --prompt-button-text: #333;
    --loader-color: var(--primary);
    --mic-button-color: var(--text-secondary);
    --mic-button-hover-color: var(--primary);
    --mic-button-active-color: #e74c3c; /* Red when listening */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Poppins', sans-serif;
}

html, body {
    height: 100%;
    overflow: hidden;
    background-color: var(--background);
    color: var(--text-primary);
}

/* --- Loader Styles --- */
.loader-overlay {
    position: fixed;
    inset: 0; /* top, right, bottom, left = 0 */
    background-color: rgba(255, 255, 255, 0.9); /* Semi-transparent white */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000; /* Highest */
    transition: opacity 0.3s ease, visibility 0.3s ease;
    opacity: 1;
    visibility: visible;
}
.loader-overlay.hidden {
    opacity: 0;
    visibility: hidden;
}
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border-left-color: var(--loader-color);
    animation: spin 1s ease infinite;
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Chat Area Loader */
#chat-loader {
    display: none; /* Hidden by default */
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%; /* Fill chat message area */
    text-align: center;
    color: var(--text-secondary);
    font-size: 0.9rem;
}
#chat-loader .spinner {
    margin-bottom: 15px;
}


/* --- Layout --- */
.chat-app { display: flex; height: 100vh; }
.sidebar {
    width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color);
    display: flex; flex-direction: column; padding: 15px; transition: width 0.3s ease; flex-shrink: 0;
}
.sidebar.hidden { width: 0; padding: 0; overflow: hidden; border: none; }
.main-content { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; position: relative; }

/* --- Sidebar Elements --- */
.new-chat-btn {
    display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid var(--border-color);
    border-radius: 8px; background-color: var(--background); color: var(--text-primary); font-size: 0.9rem;
    font-weight: 500; cursor: pointer; text-align: left; width: 100%; margin-bottom: 20px;
    transition: background-color var(--transition);
}
.new-chat-btn:hover { background-color: var(--hover-bg); }
.new-chat-btn i { color: var(--primary); }
.chat-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
.chat-list-item {
    padding: 10px 12px; border-radius: 6px; margin-bottom: 5px; cursor: pointer; white-space: nowrap;
    overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem; color: var(--text-primary);
    transition: background-color var(--transition); position: relative;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
    position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none;
    color: var(--text-secondary); cursor: pointer; font-size: 0.8rem; padding: 5px; display: none; line-height: 1;
}
.chat-list-item:hover .delete-chat-btn { display: block; }
.chat-list-item.active .delete-chat-btn { color: white; display: block; }
.chat-list-item .delete-chat-btn:hover { color: #e74c3c; }

/* --- Initial View (Welcome Screen) --- */
.initial-view {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column;
    justify-content: center; align-items: center; padding: 20px; text-align: center;
    background-color: var(--background); z-index: 10; opacity: 1; transition: opacity 0.3s ease;
}
.initial-view.hidden { opacity: 0; pointer-events: none; z-index: -1; }
.initial-view h1 { font-size: 3.5rem; font-weight: 700; color: var(--primary); margin-bottom: 30px; font-family: var(--title-font); }
.initial-input-area {
    width: 100%; max-width: 600px; display: flex; align-items: center; background-color: var(--input-bg);
    border: 1px solid var(--input-border); border-radius: 12px; padding: 5px 5px 5px 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
#initial-message-input { flex-grow: 1; border: none; outline: none; background: transparent; font-size: 1rem; color: var(--text-primary); padding: 10px 0; resize: none; line-height: 1.5; }
#initial-send-button {
    display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; text-decoration: none;
    font-weight: 500; transition: var(--transition); font-size: 1rem; border: none; cursor: pointer;
    width: 40px; height: 40px; flex-shrink: 0; margin-left: 10px; background-color: var(--primary); color: white;
}
#initial-send-button:hover { background-color: var(--primary-light); }
#initial-send-button:disabled { background-color: var(--text-secondary); opacity: 0.7; cursor: not-allowed; }

/* --- Chat View --- */
.chat-view { display: flex; flex-direction: column; height: 100%; width: 100%; position: relative; opacity: 1; transition: opacity 0.3s ease; }
.chat-view.hidden { opacity: 0; pointer-events: none; position: absolute; z-index: -1; }

/* Chat Top Bar */
.chat-top-bar {
    padding: 10px 25px; border-bottom: 1px solid var(--border-color); background-color: var(--background);
    flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; gap: 15px;
}
.chat-title-area {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
}
/* Hide the H1 title in the chat view */
.chat-top-bar h1 { display: none; }

/* Upgrade Link */
.upgrade-link {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--max-color);
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
    transition: background-color 0.2s ease;
    border: 1px solid transparent; /* Placeholder for potential border on hover */
}
.upgrade-link:hover {
    background-color: var(--max-bg);
    border-color: var(--max-color);
}
.upgrade-link i {
    margin-right: 4px;
}


/* Model Selector Container */
.model-selector-container { position: relative; display: inline-block; }
#model-selector {
    font-size: 0.9rem; font-weight: 500; color: var(--text-primary); background-color: transparent; border: none;
    padding: 2px 18px 2px 0px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none;
    outline: none; line-height: 1.4; position: relative; z-index: 1;
}
/* Style for the Max model option */
#model-selector option[value="graxybot-2.0-pro"] {
    font-weight: 600;
    color: var(--max-color);
}
/* Style for the Unhinged model option */
#model-selector option[value="graxybot-unhinged"] {
    font-weight: 600;
    color: var(--unhinged-color);
}
.model-selector-container::after { /* Dropdown arrow */
    content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 50%; right: 0px;
    transform: translateY(-50%); font-size: 0.65rem; color: var(--text-secondary); pointer-events: none; z-index: 0; transition: color var(--transition);
}
.model-selector-container:hover::after { color: var(--primary); }
#model-selector:hover { color: var(--primary); }
#model-selector:disabled { color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }
#model-selector:disabled + ::after { color: var(--text-secondary); opacity: 0.7; }

/* Personality Selector Container (Hidden by default) */
.personality-selector-container {
    position: relative; display: inline-block;
    display: none; /* Hidden by default */
}
.personality-selector-container.visible { display: inline-block; /* Show when needed */ }
#personality-selector {
    font-size: 0.85rem; font-weight: 500; color: var(--text-primary); background-color: transparent; border: none;
    padding: 2px 18px 2px 0px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none;
    outline: none; line-height: 1.4; position: relative; z-index: 1;
}
.personality-selector-container::after { /* Dropdown arrow */
    content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 50%; right: 0px;
    transform: translateY(-50%); font-size: 0.65rem; color: var(--text-secondary); pointer-events: none; z-index: 0; transition: color var(--transition);
}
.personality-selector-container:hover::after { color: var(--primary); }
#personality-selector:hover { color: var(--primary); }
#personality-selector:disabled { color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }
#personality-selector:disabled + ::after { color: var(--text-secondary); opacity: 0.7; }

/* Chat Messages Area */
/* Ensure chat messages container allows flex children to grow */
.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px 10px;
    background-color: var(--background-secondary);
    display: flex;
    flex-direction: column;
    position: relative; /* Needed for chat loader positioning */
}
.message-content-wrapper { max-width: 800px; width: 100%; margin: 0 auto 20px auto; display: flex; gap: 10px; align-items: flex-start; /* Align items to top */ }
.message-icon {
    width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary); color: white; display: flex;
    align-items: center; justify-content: center; font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #ababc5; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; width: fit-content; max-width: calc(100% - 45px); position: relative; }
.message {
    padding: 12px 18px; border-radius: 12px; line-height: 1.6; background-color: var(--bot-message-bg); color: var(--text-primary);
    word-wrap: break-word; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid var(--border-color);
    position: relative; /* Needed for speaker button */
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); }
.message p { margin: 0 0 5px 0; }
.message p:last-child { margin-bottom: 0; }
.message .timestamp { font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px; text-align: right; }
.message .sent-image {
    max-width: 200px;
    max-height: 200px;
    border-radius: 8px;
    margin-top: 8px;
    display: block;
}
/* Speaker button on bot messages */
.speak-button {
    position: absolute;
    bottom: 5px;
    right: 5px;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 0.8rem;
    padding: 3px;
    opacity: 0.6;
    transition: opacity 0.2s ease;
}
.message-bubble:hover .speak-button {
    opacity: 1;
}
.speak-button:hover {
    color: var(--primary);
}

/* --- New Chat Welcome Styles --- */
.new-chat-welcome-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center; /* Center vertically */
    text-align: center;
    flex-grow: 1; /* Allow it to take up vertical space */
    padding: 40px 20px; /* More padding */
    color: var(--text-secondary);
    overflow: auto; /* Add scroll if needed, though unlikely */
}
.welcome-title {
    font-size: 2.8rem;
    font-weight: 700;
    color: var(--primary);
    margin-bottom: 30px; /* More space below title */
    font-family: var(--title-font);
}
.suggested-prompts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Slightly wider buttons */
    gap: 15px;
    width: 100%;
    max-width: 700px; /* Wider grid */
}
.prompt-button {
    background-color: var(--prompt-button-bg);
    border: 1px solid var(--prompt-button-border);
    border-radius: 8px;
    padding: 12px 15px;
    font-size: 0.9rem;
    color: var(--prompt-button-text);
    cursor: pointer;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    text-align: left;
    font-weight: 500;
    line-height: 1.4; /* Improve readability */
}
.prompt-button:hover {
    background-color: var(--prompt-button-hover-bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}


/* Thinking Indicator Styles */
.local-thinking-indicator .message, /* Added for local model */
.reason-thinking-indicator .message {
    padding: 15px 18px;
    display: flex;
    align-items: center;
    gap: 5px;
    background-color: var(--bot-message-bg);
    border: 1px solid var(--border-color);
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.local-thinking-indicator span, /* Added for local model */
.reason-thinking-indicator span {
    display: inline-block;
    width: 8px;
    height: 8px;
    background-color: var(--text-secondary);
    border-radius: 50%;
    animation: typing 1s infinite ease-in-out;
}
.local-thinking-indicator span:nth-child(1), /* Added for local model */
.reason-thinking-indicator span:nth-child(1) { animation-delay: 0s; }
.local-thinking-indicator span:nth-child(2), /* Added for local model */
.reason-thinking-indicator span:nth-child(2) { animation-delay: 0.1s; }
.local-thinking-indicator span:nth-child(3), /* Added for local model */
.reason-thinking-indicator span:nth-child(3) { animation-delay: 0.2s; }

/* Specific style for reason thinking icon */
.reason-thinking-indicator .message-icon {
    background-color: var(--primary-active);
}
/* Specific style for local thinking icon */
.local-thinking-indicator .message-icon {
     background-color: var(--max-color); /* Use Max color */
}
/* Style for Unhinged thinking icon */
.unhinged-thinking-indicator .message-icon {
     background-color: var(--unhinged-color); /* Use Unhinged color */
}


@keyframes typing {
    0%, 100% { transform: translateY(0); opacity: 0.5; }
    50% { transform: translateY(-4px); opacity: 1; }
}

/* Code Block Styling */
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; border: 1px solid var(--code-header-bg); }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-header .language-name { font-weight: 500; text-transform: lowercase; }
.code-block-buttons button { background-color: var(--code-button-bg); border: none; color: var(--code-text-color); padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; transition: background-color var(--transition); }
.code-block-buttons button:hover { background-color: var(--code-button-hover-bg); }
.code-block-buttons button i { margin-right: 4px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; white-space: pre-wrap; }
.line-numbers .line-numbers-rows { border-right-color: var(--code-header-bg) !important; }
.line-numbers-rows > span::before { color: #6272a4 !important; }

/* Chat Input Area */
.chat-input-container {
    padding: 10px 20px 15px 20px;
    background-color: var(--background);
    border-top: 1px solid var(--border-color);
    flex-shrink: 0;
    max-width: 840px;
    margin: 0 auto;
    width: 100%;
}
/* Model Specific Notification */
#model-notification {
    font-size: 0.8rem;
    color: var(--notification-text);
    background-color: var(--notification-bg);
    padding: 4px 10px;
    border-radius: 6px;
    margin-bottom: 8px;
    text-align: center;
    display: none; /* Hidden by default */
}

.chat-input-area {
    display: flex;
    align-items: center;
    background-color: var(--input-bg);
    border: 1px solid var(--input-border);
    border-radius: 12px;
    padding: 5px 5px 5px 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
#message-input { flex-grow: 1; border: none; outline: none; background: transparent; font-size: 1rem; color: var(--text-primary); padding: 10px 0; resize: none; line-height: 1.5; }
.btn { display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; text-decoration: none; font-weight: 500; transition: var(--transition); font-size: 1rem; border: none; cursor: pointer; width: 40px; height: 40px; flex-shrink: 0; margin-left: 10px; background-color: var(--primary); color: white; }
.btn:hover { background-color: var(--primary-light); }
.btn:disabled { background-color: var(--text-secondary); opacity: 0.7; cursor: not-allowed; }

/* Microphone Button */
#mic-button {
    background: none;
    border: none;
    color: var(--mic-button-color);
    font-size: 1.2rem;
    padding: 0 8px; /* Adjust padding */
    cursor: pointer;
    transition: color 0.2s ease;
    margin-left: 5px; /* Space from input */
    width: 38px; /* Match other buttons */
    height: 38px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}
#mic-button:hover {
    color: var(--mic-button-hover-color);
}
#mic-button.listening {
    color: var(--mic-button-active-color);
    animation: pulse-mic 1.5s infinite ease-in-out;
}
@keyframes pulse-mic {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}


/* Image Upload Button */
#image-upload-button {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 1.2rem;
    padding: 0 8px; /* Adjust padding */
    cursor: pointer;
    transition: color var(--transition);
    margin-left: 0px; /* Reduced space */
    width: 38px; /* Match other buttons */
    height: 38px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}
#image-upload-button:hover {
    color: var(--primary);
}
#image-upload-input {
    display: none; /* Hide the actual file input */
}

/* Image Preview Area */
.image-preview-container {
    margin-top: 10px;
    position: relative;
    display: inline-block;
    max-width: 100px;
}
.image-preview-container img {
    display: block;
    max-width: 100%;
    height: auto;
    border: 1px solid var(--image-preview-border);
    border-radius: 6px;
}
#remove-image-button {
    position: absolute;
    top: -5px;
    right: -5px;
    background-color: var(--image-remove-bg);
    color: var(--image-remove-text);
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 0.8rem;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    font-weight: bold;
}
#remove-image-button:hover {
    background-color: rgba(0, 0, 0, 0.7);
}


/* Reason Button Area */
.input-controls-area {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 8px;
    flex-wrap: wrap;
    gap: 10px;
}
.reason-button-area {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}

#reason-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    border: 1px solid var(--reason-button-border);
    background-color: var(--reason-button-bg);
    color: var(--reason-button-text);
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
}
#reason-button:hover {
    background-color: var(--reason-button-hover-bg);
}
#reason-button.active {
    background-color: var(--reason-button-active-bg);
    border-color: var(--reason-button-active-border);
    color: var(--reason-button-active-text);
    animation: pulse-button 0.5s ease-out;
}
#reason-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}
#reason-button i {
    margin-right: 5px;
    font-size: 0.8rem;
}
#reason-usage-display {
    font-size: 0.8rem;
    color: var(--text-secondary);
    font-weight: 500;
}

@keyframes pulse-button {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}


.rate-limit-info {
    padding: 0;
    font-size: 0.85rem;
    color: var(--text-secondary);
    text-align: right;
    background-color: transparent;
    margin-top: 0;
}

/* --- Popup Styles (Update Notification) --- */
#popupOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 999;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}
#popupOverlay.visible {
    opacity: 1;
    visibility: visible;
}

.popup-content {
    background: #6B46C1;
    color: white;
    padding: 25px;
    border-radius: 10px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    position: relative;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}
#popupOverlay.visible .popup-content {
    transform: scale(1);
}

.popup-content h2 {
    margin-top: 0;
    font-size: 24px;
    color: #F3E8FF;
    margin-bottom: 15px;
}

.popup-content p {
    font-size: 16px;
    color: #E9D8FD;
    line-height: 1.5;
    margin-bottom: 10px;
}

.popup-content ul {
    list-style-type: disc;
    padding-left: 25px;
    margin-bottom: 25px;
    font-size: 16px;
    color: #E9D8FD;
}

.popup-content ul li {
    margin-bottom: 8px;
}
/* Style list items in popup */
.popup-content ul li strong {
    color: #fff; /* Make bold text white */
}


.popup-content button {
    padding: 10px 20px;
    background: #9F7AEA;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
    transition: background 0.3s ease;
    display: block;
    margin: 20px auto 0 auto;
}

.popup-content button:hover {
    background: #805AD5;
}

/* --- Max Upgrade Modal Styles --- */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 1000; /* Higher than popup */
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}
.modal-overlay.visible {
    opacity: 1;
    visibility: visible;
}
.modal-content {
    background: var(--background);
    color: var(--text-primary);
    padding: 30px;
    border-radius: 12px;
    max-width: 600px;
    width: 90%;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    position: relative;
    transform: scale(0.9);
    transition: transform 0.3s ease;
    max-height: 80vh; /* Limit height */
    overflow-y: auto; /* Allow scrolling if content overflows */
}
.modal-overlay.visible .modal-content {
    transform: scale(1);
}
.modal-content h2 {
    margin-top: 0;
    font-size: 1.8rem;
    font-weight: 700;
    color: var(--max-color);
    margin-bottom: 20px;
    text-align: center;
}
.modal-content h3 {
    font-size: 1.2rem;
    font-weight: 600;
    margin-top: 25px;
    margin-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
}
.modal-content p {
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 15px;
    color: var(--text-secondary);
}
.modal-content ul {
    list-style: none; /* Remove default bullets */
    padding-left: 0;
    margin-bottom: 20px;
}
.modal-content ul li {
    font-size: 0.95rem;
    margin-bottom: 10px;
    padding-left: 25px; /* Space for icon */
    position: relative;
}
.modal-content ul li i {
    position: absolute;
    left: 0;
    top: 4px;
    color: var(--max-color); /* Checkmark color */
    font-size: 0.9rem;
}
.modal-content .comparison-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
    margin-bottom: 30px;
}
.modal-content .plan-column h4 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 15px;
    text-align: center;
    color: var(--text-primary);
}
.modal-content .plan-column ul li {
    font-size: 0.9rem;
}
.modal-content .plan-column.free h4 { color: var(--text-secondary); }
.modal-content .plan-column.max h4 { color: var(--max-color); }
.modal-content .plan-column.max ul li i { color: var(--max-color); }
.modal-content .plan-column.free ul li i { color: var(--text-secondary); } /* Gray check for free */

.modal-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 1.5rem;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 5px;
    line-height: 1;
}
.modal-close-btn:hover {
    color: var(--text-primary);
}
.modal-upgrade-btn {
    display: block;
    width: 100%;
    padding: 12px 20px;
    background: var(--max-color);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 600;
    text-align: center;
    transition: background 0.3s ease;
    margin-top: 25px;
}
.modal-upgrade-btn:hover {
    background: #a337bd; /* Darker Max color */
}
.modal-upgrade-btn i {
    margin-right: 8px;
}


/* --- Responsive Adjustments --- */
@media (max-width: 768px) {
    .sidebar { width: 200px; }
    .chat-top-bar { padding: 10px 15px; }
    #model-selector { font-size: 0.85rem; }
    #personality-selector { font-size: 0.8rem; }
    .initial-view h1 { font-size: 2.5rem; }
    .message-content-wrapper { padding: 0 15px; max-width: 95%; gap: 10px;} /* Restored gap */
    .message-icon { width: 28px; height: 28px; font-size: 0.8rem;}
    .message-bubble { max-width: calc(100% - 38px); } /* Restored width */
    .message { padding: 10px 15px; }
    .code-block-container pre[class*="language-"] { font-size: 0.85rem; }
    .chat-input-container { padding: 10px 15px; max-width: 95%; }
    .chat-input-area { padding: 5px 5px 5px 12px; }
    #message-input { font-size: 0.95rem; }
    .btn, #mic-button { width: 38px; height: 38px; } /* Adjust mic button size */
    #initial-send-button { width: 38px; height: 38px; }
    #reason-button { font-size: 0.8rem; padding: 5px 10px; }
    #reason-usage-display { font-size: 0.75rem; }
    .image-preview-container { max-width: 80px; }
    #model-notification { font-size: 0.75rem; padding: 3px 8px;}
    .popup-content h2 { font-size: 20px; }
    .popup-content p, .popup-content ul { font-size: 15px; }
    .modal-content { padding: 20px; max-width: 95%; }
    .modal-content h2 { font-size: 1.5rem; }
    .modal-content .comparison-grid { grid-template-columns: 1fr; } /* Stack columns */
    .welcome-title { font-size: 2.2rem; }
    .suggested-prompts-grid { grid-template-columns: 1fr; } /* Stack prompts */
}

@media (max-width: 600px) {
    body { padding: 0; }
    .chat-top-bar { padding: 8px 10px; flex-wrap: wrap; }
    .chat-title-area {
        width: 100%;
        flex-direction: row;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: flex-start;
        margin-bottom: 5px;
    }
    #model-selector { font-size: 0.8rem; padding-right: 15px;}
    #personality-selector { font-size: 0.75rem; padding-right: 15px; }
    .model-selector-container::after, .personality-selector-container::after { font-size: 0.6rem; right: 0px;}
    .initial-view h1 { font-size: 2rem; }
    .chat-messages { padding: 15px 0px; }
    .message-content-wrapper { padding: 0 10px; gap: 8px; } /* Restored gap */
    .message-icon { width: 25px; height: 25px; font-size: 0.7rem;}
    .message-bubble { max-width: calc(100% - 33px); } /* Restored width */
    .code-block-container pre[class*="language-"] { font-size: 0.8rem; }
    .chat-input-container { padding: 8px 10px; }
    .chat-input-area { padding: 3px 3px 3px 10px; }
    #message-input { padding: 8px 0; }
    .btn, #mic-button { width: 36px; height: 36px; } /* Adjust mic button size */
    #initial-send-button { width: 36px; height: 36px; }
    #reason-button { font-size: 0.75rem; padding: 4px 8px; }
    #reason-usage-display { font-size: 0.7rem; }
    .reason-button-area { gap: 6px; }
    .image-preview-container { max-width: 60px; }
    #image-upload-button { padding: 0 8px; font-size: 1.1rem;}
    #model-notification { font-size: 0.7rem; padding: 2px 6px;}
    .popup-content { padding: 20px; }
    .popup-content h2 { font-size: 18px; }
    .popup-content p, .popup-content ul { font-size: 14px; }
    .popup-content button { padding: 8px 16px; font-size: 14px; }
    .modal-content h2 { font-size: 1.3rem; }
    .modal-content h3 { font-size: 1.1rem; }
    .modal-content p, .modal-content ul li { font-size: 0.9rem; }
    .modal-upgrade-btn { font-size: 0.95rem; padding: 10px 15px; }
    .welcome-title { font-size: 2rem; }
    .prompt-button { font-size: 0.85rem; padding: 10px; }
}

</style>
</head>
<body>

<div id="initial-loader" class="loader-overlay">
    <div class="spinner"></div>
</div>

<div id="popupOverlay">
    <div class="popup-content">
        <h2>Graxybot Web Release 1.0 is Here!</h2>
        <p>Explore the latest features now available:</p>
        <ul>
            <li><strong>New Model:</strong> Access `graxybot-unhinged` (powered by Llama2-Uncensored).</li>
            <li><strong>Graxybot Max:</strong> Try the "infinite free trial" for Max features, including `graxybot-2.0-pro`.</li>
            <li>Multiple Models: Choose between Flash, Experimental (with personalities), and Global Sheets optimized models.</li>
            <li>Reason Mode: Enhance responses with Gemini 1.5 Pro (limited daily uses).</li>
            <li>Image Upload: Send images along with your text prompts.</li>
            <li><strong>Coming Soon:</strong> Voice mode rollout.</li>
        </ul>
        <button id="closePopupButton">Close</button>
        </div>
</div>

<div id="maxUpgradeModal" class="modal-overlay">
    <div class="modal-content">
        <button id="modalCloseBtn" class="modal-close-btn" title="Close">&times;</button>
        <h2><i class="fas fa-rocket"></i> Upgrade to Graxybot Max</h2>
        <p>Unlock the full potential of Graxybot with exclusive features and enhanced capabilities.</p>

        <div class="comparison-grid">
            <div class="plan-column free">
                <h4>Free</h4>
                <ul>
                    <li><i class="fas fa-check"></i> Standard Models (Flash, Experimental)</li>
                    <li><i class="fas fa-check"></i> Reason Mode (20/day)</li>
                    <li><i class="fas fa-times"></i> Graxybot-2.0-Pro Access</li>
                    <li><i class="fas fa-times"></i> Graxybot Unhinged Access</li>
                    <li><i class="fas fa-check"></i> Standard Usage Limits (15/5min)</li>
                    <li><i class="fas fa-times"></i> Priority Voice Mode Access</li>
                </ul>
            </div>
            <div class="plan-column max">
                <h4>Max</h4>
                <ul>
                    <li><i class="fas fa-check"></i> All Standard Models</li>
                    <li><i class="fas fa-check"></i> Reason Mode (20/day)</li>
                    <li><i class="fas fa-check"></i> **Graxybot-2.0-Pro Access** (Local)</li>
                    <li><i class="fas fa-check"></i> **Graxybot Unhinged Access** (Local)</li>
                    <li><i class="fas fa-check"></i> **Higher Usage Limits** (14/min simulated)</li>
                    <li><i class="fas fa-check"></i> **Priority Voice Mode Access** (Coming Soon)</li>
                </ul>
            </div>
        </div>

        <button id="startTrialBtn" class="modal-upgrade-btn">
            <i class="fas fa-star"></i> Start Infinite "Free Trial"
        </button>
    </div>
</div>


<div class="chat-app">
    <aside class="sidebar">
        <button class="new-chat-btn" id="new-chat-btn">
            <i class="fas fa-plus"></i> New Chat
        </button>
        <ul class="chat-list" id="chat-list">
            </ul>
    </aside>

    <main class="main-content">
        <div class="initial-view" id="initial-view">
            <h1>Graxybot</h1>
            <div class="initial-input-area">
                <input type="text" id="initial-message-input" placeholder="Ask me anything...">
                <button id="initial-send-button" class="btn" title="Send Message">
                    <i class="fas fa-arrow-up"></i>
                </button>
            </div>
        </div>

        <div class="chat-view hidden" id="chat-view">
            <div class="chat-top-bar">
                <div class="chat-title-area">
                    <div class="model-selector-container">
                        <select id="model-selector">
                            <option value="graxybot-1.0-flash">graxybot-1.0-flash</option>
                            <option value="graxybot-1.5-experimental">graxybot-1.5 (experimental)</option>
                            <option value="graxybot-global-sheets">graxybot-global-sheets</option>
                            <option value="graxybot-2.0-pro">graxybot-2.0-pro (Max)</option>
                            <option value="graxybot-unhinged">Graxybot Unhinged</option> </select>
                    </div>
                    <div class="personality-selector-container" id="personality-selector-container">
                        <select id="personality-selector">
                            <option value="default">Personality: Default</option>
                            <option value="romantic">Personality: Romantic</option>
                            <option value="sad">Personality: Sad</option>
                            <option value="angry">Personality: Angry</option>
                            <option value="pirate">Personality: Pirate</option>
                        </select>
                    </div>
                    <h1 id="chat-view-title">Graxybot</h1> </div>
                <span id="upgradeLink" class="upgrade-link" style="display: none;">
                    <i class="fas fa-arrow-up"></i> Upgrade to Max
                </span>
            </div>

            <div class="chat-messages" id="chat-messages">
                 <div id="chat-loader">
                    <div class="spinner"></div>
                    <span>Loading Chat...</span>
                 </div>
                </div>

            <div class="chat-input-container">
                 <div id="model-notification" style="display: none;"></div>
                 <div class="chat-input-area">
                    <button id="image-upload-button" title="Attach Image"><i class="fas fa-paperclip"></i></button>
                    <input type="file" id="image-upload-input" accept="image/*">
                    <input type="text" id="message-input" placeholder="Message Graxybot...">
                    <button id="mic-button" class="btn" title="Start Voice Input">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button id="send-button" class="btn" title="Send Message"><i class="fas fa-arrow-up"></i></button>
                 </div>
                 <div id="image-preview-area" class="image-preview-container" style="display: none;">
                    <img id="image-preview" src="#" alt="Image preview"/>
                    <button id="remove-image-button" title="Remove image">&times;</button>
                 </div>
                 <div class="input-controls-area">
                    <div class="reason-button-area">
                        <button id="reason-button" title="Use enhanced reasoning (Gemini 1.5 Pro) for the next message."><i class="fas fa-brain"></i> Reason</button>
                        <span id="reason-usage-display">Uses: 0/20</span>
                    </div>
                    <div id="rate-limit-message" class="rate-limit-info" style="display: none;"></div>
                 </div>
            </div>
        </div>
    </main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-SkmBfuA2hqjzEVNWb8CUApVR5fFWrSDcUOahSEgUd07FNMef+AbUd/yPkMkNUabIMZrcOg/1wslzAZMuUrNmA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-BttltKXFyWnGZQcRWj6UJFdLmWhtQxfqVfRMS9EDGDpMh/Db82MACoMMQqGWf0Y69Fc27TwnXyIE+fsHLugUDw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script type="importmap">
{
    "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai"
    }
}
</script>

<script type="module">
    import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";

    // --- Configuration ---
    const API_KEY = "AIzaSyBbj7cDi0Oa86lUN5963IThL0R1pffgDkk"; // <-- PASTE YOUR ACTUAL GOOGLE AI API KEY HERE
    const LOCAL_MODEL_URL = "https://hiv-plastics-unions-individually.trycloudflare.com"; // <-- YOUR LOCAL SERVER URL

    // --- Model Definitions ---
    const modelMapping = { // For Google AI models
        "graxybot-1.0-flash": "gemini-1.5-flash-latest",
        "graxybot-1.5-experimental": "gemini-1.5-flash-latest",
        "graxybot-global-sheets": "gemini-1.5-flash-latest"
    };
    const GRAXYBOT_MAX_MODEL_NAME = "graxybot-2.0-pro"; // Display name for your qwen model
    const GRAXYBOT_UNHINGED_MODEL_NAME = "graxybot-unhinged"; // Display name for llama2-uncensored
    const REASON_MODE_MODEL = "gemini-1.5-pro-latest";
    const REASON_MODE_DISPLAY_NAME = "graxybot-1.0-reason";
    const GLOBAL_SHEETS_MODEL_NAME = "graxybot-global-sheets";
    const DEFAULT_FAKE_MODEL = "graxybot-1.0-flash";
    const EXPERIMENTAL_MODEL_NAME = "graxybot-1.5-experimental";
    const DEFAULT_PERSONALITY = "default";

    // --- UI & Storage Keys ---
    const BOT_ICON_SRC = "graxybot.png"; // Optional: Path to bot icon image
    const USER_ICON_CLASS = "fas fa-user";
    const CHATS_STORAGE_KEY = "graxybot_all_chats_v2";
    const CURRENT_CHAT_ID_KEY = "graxybot_current_chat_id";
    const MODEL_STORAGE_KEY = "graxybot_selected_model";
    const REASON_USAGE_DATE_KEY = "graxybot_reason_usage_date";
    const REASON_USAGE_COUNT_KEY = "graxybot_reason_usage_count";
    const MAX_STATUS_KEY = "graxybot_max_status"; // localStorage key for Max status

    // --- Limits & Settings ---
    const MAX_MESSAGES_PER_WINDOW = 15;
    const TIME_WINDOW_MS = 5 * 60 * 1000; // 5 minutes
    const MAX_REASON_USES_PER_DAY = 20;
    const MIN_REASON_DELAY_MS = 10000;
    const MAX_REASON_DELAY_MS = 30000;
    let messageTimestamps = [];
    const safetySettings = [
        { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    ];

    // --- DOM Element References ---
    let chatMessagesContainer, messageInput, sendButton, rateLimitMessageDiv, modelSelector;
    let initialView, chatView, initialMessageInput, initialSendButton;
    let sidebar, newChatBtn, chatListUl;
    let personalitySelectorContainer, personalitySelector;
    let reasonButton, reasonUsageDisplay;
    let imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton;
    let modelNotificationDiv;
    let popupOverlay, closePopupButton;
    let upgradeLink, maxUpgradeModal, modalCloseBtn, startTrialBtn; // Max related UI
    let initialLoader, chatLoader; // Loader elements
    let micButton; // Voice input button

    // --- Application State ---
    let genAI;
    let currentChatSession = null;
    let chats = {};
    let currentChatId = null;
    let isInitializing = false;
    let isReasonModeActive = false;
    let currentThinkingIndicatorElement = null; // Unified indicator reference
    let selectedImageData = null;
    let selectedImageMimeType = null;
    let selectedImagePreviewUrl = null;
    let isMaxUser = false; // Subscription status flag
    let isListening = false; // Voice input status
    let recognition = null; // SpeechRecognition instance
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const synthesis = window.speechSynthesis;

    // --- Core Functions ---

    function generateChatId() { /* ... (no changes) ... */
        return `chat_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
    }

    function loadAllChats() {
        try {
            const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
            if (storedChats) {
                const parsedChats = JSON.parse(storedChats);
                if (typeof parsedChats === 'object' && parsedChats !== null) {
                    Object.keys(parsedChats).forEach(id => {
                        if (!parsedChats[id]) return;
                        if (!Array.isArray(parsedChats[id].history)) { parsedChats[id].history = []; }
                        if (parsedChats[id].model === EXPERIMENTAL_MODEL_NAME && typeof parsedChats[id].personality === 'undefined') {
                            parsedChats[id].personality = DEFAULT_PERSONALITY;
                        } else if (parsedChats[id].model !== EXPERIMENTAL_MODEL_NAME) {
                            delete parsedChats[id].personality;
                        }
                        // Check if model exists in mapping OR is one of the local models
                        const isKnownLocalModel = [GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME].includes(parsedChats[id].model);
                        if (!parsedChats[id].model || (!modelMapping[parsedChats[id].model] && !isKnownLocalModel)) {
                             parsedChats[id].model = DEFAULT_FAKE_MODEL;
                        }
                    });
                    console.log(`Loaded ${Object.keys(parsedChats).length} chats from localStorage.`);
                    return parsedChats;
                }
            }
        } catch (error) {
            console.error("Error loading chats from localStorage:", error);
            localStorage.removeItem(CHATS_STORAGE_KEY);
        }
        return {};
     }

    function saveAllChats() { /* ... (no changes) ... */
         try { localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats)); } catch (error) { console.error("Error saving chats to localStorage:", error); }
    }

    function loadCurrentChatId() { /* ... (no changes) ... */
        const storedId = localStorage.getItem(CURRENT_CHAT_ID_KEY);
        return (storedId && chats[storedId]) ? storedId : null;
    }

    function saveCurrentChatId() { /* ... (no changes) ... */
        if (currentChatId) { localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId); } else { localStorage.removeItem(CURRENT_CHAT_ID_KEY); }
    }

    function loadSelectedModelPreference() {
        const savedModel = localStorage.getItem(MODEL_STORAGE_KEY);
        // Allow Max and Unhinged models as preferences too
        const knownLocalModels = [GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME];
        if (savedModel && (modelMapping[savedModel] || knownLocalModels.includes(savedModel))) {
            return savedModel;
        }
        return DEFAULT_FAKE_MODEL;
    }

    function saveSelectedModelPreference(fakeModelName) {
        const knownLocalModels = [GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME];
        if (modelMapping[fakeModelName] || knownLocalModels.includes(fakeModelName)) {
            localStorage.setItem(MODEL_STORAGE_KEY, fakeModelName);
        }
    }

    // --- Max Subscription Status ---
    function loadMaxStatus() {
        const status = localStorage.getItem(MAX_STATUS_KEY);
        isMaxUser = status === 'true'; // Update global flag
        console.log(`Max status loaded: ${isMaxUser}`);
    }

    function saveMaxStatus() {
        localStorage.setItem(MAX_STATUS_KEY, isMaxUser.toString());
        console.log(`Max status saved: ${isMaxUser}`);
    }

    /** Updates UI elements related to Max status (e.g., hide/show upgrade link) */
    function updateMaxUI() {
        if (upgradeLink) {
            upgradeLink.style.display = isMaxUser ? 'none' : 'inline-block';
        }
    }

    // --- Reason Mode Usage ---
    function getTodayDateString() { /* ... (no changes) ... */
         return new Date().toISOString().split('T')[0];
    }
    function getReasonUsage() { /* ... (no changes) ... */
        const today = getTodayDateString();
        const lastUsageDate = localStorage.getItem(REASON_USAGE_DATE_KEY);
        let count = 0;
        if (lastUsageDate === today) {
            count = parseInt(localStorage.getItem(REASON_USAGE_COUNT_KEY) || '0', 10);
        } else {
            localStorage.setItem(REASON_USAGE_DATE_KEY, today);
            localStorage.setItem(REASON_USAGE_COUNT_KEY, '0');
            count = 0;
            console.log("Reason usage count reset for the new day.");
        }
        return count;
     }
    function incrementReasonUsage() { /* ... (no changes) ... */
        const today = getTodayDateString();
        const lastUsageDate = localStorage.getItem(REASON_USAGE_DATE_KEY);
        if (lastUsageDate !== today) {
            localStorage.setItem(REASON_USAGE_DATE_KEY, today);
            localStorage.setItem(REASON_USAGE_COUNT_KEY, '1');
        } else {
            let count = parseInt(localStorage.getItem(REASON_USAGE_COUNT_KEY) || '0', 10);
            count++;
            localStorage.setItem(REASON_USAGE_COUNT_KEY, count.toString());
        }
        updateReasonButtonState();
    }
    function updateReasonButtonState() { /* ... (no changes) ... */
        if (!reasonButton || !reasonUsageDisplay) return;
        const usedCount = getReasonUsage();
        const remaining = MAX_REASON_USES_PER_DAY - usedCount;
        reasonUsageDisplay.textContent = `Uses: ${remaining}/${MAX_REASON_USES_PER_DAY}`;
        reasonButton.title = `Use enhanced reasoning (${REASON_MODE_DISPLAY_NAME}) for the next message. ${remaining} uses remaining today.`;
        reasonButton.disabled = (remaining <= 0 && !isReasonModeActive);
    }


    // --- System Prompt Generation ---
    /**
     * Generates the system prompt text based on the selected model, personality, and reason mode.
     * Includes instruction to avoid showing internal thinking.
     * NOTE: This is primarily for Google AI models. Local models get instructions via user prompt.
     * @param {string} fakeModelName - The display name of the model (e.g., "graxybot-1.0-flash").
     * @param {string} [personality='default'] - The selected personality (only relevant for experimental model).
     * @param {boolean} [isReasoning=false] - Whether the Reason (Pro) model is being used for this specific request.
     * @returns {string} The generated system prompt text.
     */
    function getSystemPrompt(fakeModelName, personality = DEFAULT_PERSONALITY, isReasoning = false) {
        // Return empty string if it's a known local model, as they don't use system prompts this way
        if ([GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME].includes(fakeModelName)) {
            return "";
        }

        let displayModelName = modelMapping[fakeModelName] ? fakeModelName : DEFAULT_FAKE_MODEL;
        if (isReasoning) { displayModelName = REASON_MODE_DISPLAY_NAME; }

        // Base prompt + Instruction to hide thinking for Google models
        let basePrompt = `You are Graxybot, a helpful AI assistant. You are currently running on the ${displayModelName} model. Your creator is 'thegraxisreal'. Provide only the final answer, without revealing your internal thought process or reasoning steps unless explicitly asked to explain.`;

        // Add model-specific instructions or personality traits
        if (fakeModelName === GLOBAL_SHEETS_MODEL_NAME) {
            basePrompt += ` You are optimized to analyze screenshots of Google Sheets containing social studies questions. IMPORTANT: Answer all questions in all lowercase. Do not restate the question. DO NOT EVER RESTATE QUESTION. EVER. Do not use symbols like - or ;. Keep answers 9th grade level. Answer all question numbers the user provides. Provide very simple, direct answers. For example, if the question is "what is the most populated continent?", respond only with "asia". For short answer questions, respond in 1-2 simple, lowercase sentences.`;
        } else if (isReasoning) {
            // Instructions when Reason mode (Pro model) is active
            basePrompt += ` IMPORTANT: You are currently in enhanced reasoning mode (${REASON_MODE_DISPLAY_NAME}), utilizing the Gemini 1.5 Pro model. Provide more detailed, insightful, and analytical responses where appropriate. When generating code in this mode, ensure it is exceptionally well-structured, commented, robust, and follows best practices (very very good code). Keep your responses concise, helpful, and slightly informal. Avoid overly complex language unless necessary. Refer to yourself as Graxybot. When asked for code, default to HTML. When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\`.`;
        } else {
            // Default instructions for Flash and Experimental models (when not reasoning)
            basePrompt += ` Keep your responses concise, helpful, and slightly informal. Avoid overly complex language unless necessary. Do not mention that you are running on a Google model unless specifically asked about your underlying technology. Refer to yourself as Graxybot. When asked for code, default to HTML. When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\`.`;

            // Add personality instructions ONLY if the experimental model is selected AND we are NOT in reasoning mode
            if (fakeModelName === EXPERIMENTAL_MODEL_NAME) {
                switch (personality) {
                    case 'romantic': basePrompt += " IMPORTANT: Adopt a romantic, slightly poetic, and charming personality..."; break;
                    case 'sad': basePrompt += " IMPORTANT: Adopt a melancholic, slightly sad, and introspective personality..."; break;
                    case 'angry': basePrompt += " IMPORTANT: Adopt an angry, easily annoyed, and grumpy personality..."; break;
                    case 'pirate': basePrompt += " IMPORTANT: Adopt the personality of a swashbuckling pirate!..."; break;
                    default: break;
                }
            }
        }
        return basePrompt;
     }


    function addMessageToCurrentChatHistory(role, content, imagePreview = null) { /* ... (no changes) ... */
         if (!currentChatId || !chats[currentChatId]) { console.error("Cannot save message to history: No active chat selected or chat data missing."); return; }
        if (!Array.isArray(chats[currentChatId].history)) { chats[currentChatId].history = []; }
        let messageData;
        if (typeof content === 'string') { messageData = { role, parts: [{ text: content }] }; }
        else if (Array.isArray(content)) { messageData = { role, parts: content }; }
        else { console.warn("Attempted to save message with invalid content format:", content); return; }
        if (role === 'user' && imagePreview) { messageData.imagePreview = imagePreview; }
        chats[currentChatId].history.push(messageData);
        const userMessages = chats[currentChatId].history.filter(m => m.role === 'user');
        if (userMessages.length === 1 && role === 'user') {
            const firstTextPart = messageData.parts.find(p => p.text);
            const textForTitle = (firstTextPart && firstTextPart.text) ? firstTextPart.text.trim() : (imagePreview ? "[Image Sent]" : "New Chat");
            chats[currentChatId].title = textForTitle.substring(0, 35) + (textForTitle.length > 35 ? '...' : '');
            renderChatList();
        }
        saveAllChats();
    }

    // --- UI Display Functions ---

    /** Unified function to show a thinking indicator */
    function showThinkingIndicator(type = 'reason') {
        removeThinkingIndicator(); // Remove any existing one first

        let indicatorClass = '';
        let indicatorText = 'Thinking...';
        let senderType = 'bot'; // Default sender type for displayMessage

        if (type === 'reason') {
            indicatorClass = 'reason-thinking-indicator';
            senderType = 'reason-thinking'; // Use specific sender for styling
        } else if (type === 'local') { // Covers both Max and Unhinged now
            indicatorClass = 'local-thinking-indicator';
            indicatorText = 'Thinking (Local)...';
            senderType = 'bot'; // Use standard bot sender for local
        } else {
            console.warn("Unknown thinking indicator type:", type);
            return; // Don't show indicator for unknown types
        }

        // Display the new indicator message
        currentThinkingIndicatorElement = displayMessage('', senderType); // Display empty bubble with correct icon/sender type
        if (currentThinkingIndicatorElement) {
             currentThinkingIndicatorElement.classList.add(indicatorClass); // Add specific class for animation/styling
             const msgDiv = currentThinkingIndicatorElement.querySelector('.message');
             if(msgDiv) {
                 msgDiv.innerHTML = `<span></span><span></span><span></span> ${indicatorText}`; // Add dots and text
             } else {
                 console.error("Could not find message div within indicator element.");
             }
             // CSS classes handle icon background colors

        } else {
            console.error("Failed to create thinking indicator element.");
        }
    }

    /** Unified function to remove any thinking indicator */
    function removeThinkingIndicator() {
        if (currentThinkingIndicatorElement && currentThinkingIndicatorElement.parentNode) {
            try {
                currentThinkingIndicatorElement.parentNode.removeChild(currentThinkingIndicatorElement);
            } catch (e) {
                console.warn("Error removing thinking indicator:", e); // Log potential errors during removal
            } finally {
                 currentThinkingIndicatorElement = null;
            }
        }
        // Cleanup orphaned indicators
        const indicators = chatMessagesContainer?.querySelectorAll('.reason-thinking-indicator, .local-thinking-indicator'); // Look for both classes
        indicators?.forEach(el => {
            try {
                el.parentNode?.removeChild(el);
            } catch (e) {
                 console.warn("Error removing orphaned indicator:", e);
            }
        });
    }


    function displayMessage(content, sender, isError = false, imagePreview = null) {
        if (!chatMessagesContainer) { console.error("Chat message container not found in displayMessage"); return null; };
        const wrapper = document.createElement('div');
        wrapper.classList.add('message-content-wrapper');
        wrapper.dataset.messageId = `msg_${Date.now()}_${Math.random().toString(36).substring(2, 5)}`;

        // Add base class based on sender
        if (sender === 'user') wrapper.classList.add('user-message');
        else if (sender === 'bot' || sender === 'reason-thinking' || sender === 'local-thinking') {
            // Treat all bot/indicator types as 'bot-message' for layout purposes
            wrapper.classList.add('bot-message');
        }

        if (isError) wrapper.classList.add('error-message');

        // --- Create Icon ---
        const iconDiv = document.createElement('div');
        iconDiv.classList.add('message-icon');
        const img = document.createElement('img');
        img.src = BOT_ICON_SRC; // Assume bot icon for bot/indicators
        img.alt = "G";

        if (sender === 'user') {
            iconDiv.classList.add('user-icon');
            iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
        } else { // Bot or Indicator
            img.onerror = () => iconDiv.innerHTML = '<i class="fas fa-robot"></i>'; // Default fallback
            if (sender === 'reason-thinking') {
                // CSS class .reason-thinking-indicator .message-icon handles background
                img.onerror = () => iconDiv.innerHTML = '<i class="fas fa-brain"></i>'; // Reason fallback
            } else if (sender === 'local-thinking') {
                 // CSS class .local-thinking-indicator .message-icon handles background
                 img.onerror = () => iconDiv.innerHTML = '<i class="fas fa-server"></i>'; // Local fallback
            }
            iconDiv.appendChild(img);
        }

        // --- Create Message Bubble ---
        const bubbleDiv = document.createElement('div');
        bubbleDiv.classList.add('message-bubble');

        // --- Handle Content ---
        if (sender === 'reason-thinking' || sender === 'local-thinking') {
            // Display animated dots for indicators
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            // Text is now added by showThinkingIndicator
            bubbleDiv.appendChild(messageDiv);
        } else { // Regular user/bot messages
            const messageDiv = createTextMessageDiv('');
            const paragraph = messageDiv.querySelector('p');
            if (paragraph) paragraph.dataset.streamTarget = "true";

            let textContent = '';
            if (Array.isArray(content)) {
                const textPart = content.find(part => part.text);
                textContent = textPart ? textPart.text : '';
            } else if (typeof content === 'string') {
                textContent = content;
            }

            if (textContent && paragraph) {
                processAndAppendText(textContent, paragraph);
            } else if (!imagePreview && sender !== 'bot' && paragraph) {
                 paragraph.textContent = "[Empty Message]";
            }

            if (sender === 'user' && imagePreview) {
                const imgElement = document.createElement('img');
                imgElement.src = imagePreview;
                imgElement.alt = "Sent image preview";
                imgElement.classList.add('sent-image');
                if (paragraph && paragraph.hasChildNodes()) {
                    messageDiv.insertBefore(imgElement, paragraph);
                } else {
                    messageDiv.appendChild(imgElement);
                }
            }

            bubbleDiv.appendChild(messageDiv);

            if (sender === 'user') {
                const timestampSpan = document.createElement('span');
                timestampSpan.classList.add('timestamp');
                timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                bubbleDiv.appendChild(timestampSpan);
            }
            // Timestamp and speaker button for bot added after response complete
            else if (sender === 'bot' && !isError) {
                 // Add speaker button after processing
                 const speakBtn = document.createElement('button');
                 speakBtn.className = 'speak-button';
                 speakBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                 speakBtn.title = 'Read aloud';
                 speakBtn.onclick = (event) => {
                    event.stopPropagation();
                    // Find the text content within this specific message bubble
                    const textToSpeak = Array.from(bubbleDiv.querySelectorAll('p, code')) // Select relevant elements
                                            .map(el => el.textContent)
                                            .join('\n'); // Join paragraphs/code
                    speakText(textToSpeak);
                 };
                 messageDiv.appendChild(speakBtn); // Append to the message div itself
            }
        }

        wrapper.appendChild(iconDiv);
        wrapper.appendChild(bubbleDiv);
        chatMessagesContainer.appendChild(wrapper);

        requestAnimationFrame(() => {
            chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
        });

        // Speak the message if it's from the bot and not an error
        if (sender === 'bot' && !isError) {
             const textToSpeak = Array.from(bubbleDiv.querySelectorAll('p, code'))
                                     .map(el => el.textContent)
                                     .join('\n');
             speakText(textToSpeak);
        }

        return wrapper;
    }

    function processAndAppendText(text, targetElement) { /* ... (no changes) ... */
        const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;
        let hasCode = false;
        targetElement.innerHTML = ''; // Clear first

        while ((match = codeBlockRegex.exec(text)) !== null) {
            hasCode = true;
            const textBefore = text.substring(lastIndex, match.index);
            targetElement.innerHTML += textBefore.replace(/\n/g, '<br>');

            const lang = match[1]?.trim() || 'plaintext';
            const code = match[2].trim();
            const codeContainer = document.createElement('div');
            codeContainer.classList.add('code-block-container');
            const header = document.createElement('div');
            header.classList.add('code-block-header');
            const langSpan = document.createElement('span');
            langSpan.classList.add('language-name');
            langSpan.textContent = lang;
            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('code-block-buttons');
            const copyBtn = document.createElement('button');
            copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
            copyBtn.title = "Copy code";
            copyBtn.onclick = ((codeToCopy) => () => handleCopyCode(codeToCopy, copyBtn))(code);
            buttonsDiv.appendChild(copyBtn);
            const lowerLang = lang.toLowerCase();
            if (['html', 'javascript', 'js'].includes(lowerLang)) {
                const runBtn = document.createElement('button');
                runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
                runBtn.title = `Run ${lang} code snippet`;
                runBtn.onclick = ((codeToRun, langToRun) => () => handleRunCode(codeToRun, langToRun))(code, lowerLang);
                buttonsDiv.appendChild(runBtn);
            }
            header.appendChild(langSpan);
            header.appendChild(buttonsDiv);
            codeContainer.appendChild(header);
            const pre = document.createElement('pre');
            pre.className = 'line-numbers';
            const codeEl = document.createElement('code');
            codeEl.className = `language-${lang}`;
            codeEl.textContent = code;
            pre.appendChild(codeEl);
            codeContainer.appendChild(pre);
            targetElement.appendChild(codeContainer);
            lastIndex = codeBlockRegex.lastIndex;
        }
        const textAfter = text.substring(lastIndex);
        targetElement.innerHTML += textAfter.replace(/\n/g, '<br>');
        return hasCode;
    }

    function createTextMessageDiv(text) { /* ... (no changes) ... */
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        const paragraph = document.createElement('p');
        paragraph.textContent = text;
        messageDiv.appendChild(paragraph);
        return messageDiv;
    }

    function handleCopyCode(codeContent, buttonElement) { /* ... (no changes) ... */
        navigator.clipboard.writeText(codeContent).then(() => {
            console.log("Code copied");
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = '<i class="fas fa-check"></i> Copied!';
            buttonElement.disabled = true;
            setTimeout(() => { buttonElement.innerHTML = originalText; buttonElement.disabled = false; }, 1500);
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = '<i class="fas fa-times"></i> Error';
            setTimeout(() => { buttonElement.innerHTML = originalText; buttonElement.disabled = false; }, 2000);
        });
    }

    function handleRunCode(codeContent, language) { /* ... (no changes) ... */
         console.log(`Running ${language} code...`);
        try {
            let htmlToRun = '';
            if (language === 'html') { htmlToRun = codeContent; }
            else if (language === 'javascript' || language === 'js') {
                htmlToRun = `<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>JS Runner</title><style>body{font-family:monospace;background-color:#f0f0f0;padding:15px;font-size:.9em;color:#333}h1{font-size:1.2em;color:#555;border-bottom:1px solid #ccc;padding-bottom:5px;margin-bottom:10px}pre{background-color:#fff;padding:10px;border:1px solid #ccc;border-radius:5px;white-space:pre-wrap;word-wrap:break-word;font-size:.95em;max-height:80vh;overflow-y:auto}.error{color:#D8000C;font-weight:700;background-color:#FFD2D2;padding:2px 4px;border-radius:3px}.log-entry{margin-bottom:4px}</style></head><body><h1>JavaScript Output:</h1><pre id="output"></pre><script>
const outputElement=document.getElementById("output"),originalConsoleLog=console.log,originalConsoleError=console.error,logHistory=[];const formatArg=e=>{if(e instanceof Error)return\`Error: \${e.message}\n\${e.stack}\`;if("object"==typeof e&&null!==e)try{return JSON.stringify(e,null,2)}catch{return String(e)}return String(e)};console.log=(...e)=>{const o=e.map(formatArg).join(" ");logHistory.push(\`<div class="log-entry">\${o.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>\`),outputElement.innerHTML=logHistory.join(""),originalConsoleLog.apply(console,e)},console.error=(...e)=>{const o=e.map(formatArg).join(" ");logHistory.push(\`<div class="log-entry error">ERROR: \${o.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>\`),outputElement.innerHTML=logHistory.join(""),originalConsoleError.apply(console,e)},window.addEventListener("unhandledrejection",e=>{console.error("Unhandled Promise Rejection:",e.reason)}),window.addEventListener("error",e=>{console.error("Script Error:",e.message,"at",e.filename,":",e.lineno)});try{${codeContent}}catch(e){console.error("Execution Error:",e)}<\/script></body></html>`;
            } else { console.warn("Run action not supported for language:", language); alert(`Running code directly is not supported for ${language}.`); return; }
            const newTab = window.open('about:blank', '_blank');
            if (newTab) { newTab.document.open(); newTab.document.write(htmlToRun); newTab.document.close(); console.log("Code execution tab opened."); }
            else { alert("Could not open new tab. Please check if pop-ups are blocked."); }
        } catch (error) { console.error("Error preparing or running code:", error); alert("An error occurred while trying to run the code."); }
    }

    function isRateLimited() { /* ... (no changes) ... */
        const now = Date.now();
        messageTimestamps = messageTimestamps.filter(timestamp => now - timestamp < TIME_WINDOW_MS);
        if (messageTimestamps.length >= MAX_MESSAGES_PER_WINDOW) {
            console.warn(`Rate limit exceeded: ${messageTimestamps.length} messages in the last ${TIME_WINDOW_MS / 1000} seconds.`);
            if (rateLimitMessageDiv) {
                rateLimitMessageDiv.textContent = `Rate limit reached (${MAX_MESSAGES_PER_WINDOW} messages/${TIME_WINDOW_MS / 1000 / 60} min). Please wait.`;
                rateLimitMessageDiv.style.display = 'block';
                setTimeout(() => { if (rateLimitMessageDiv) rateLimitMessageDiv.style.display = 'none'; }, 3000);
            }
            return true;
        }
        return false;
    }

    function switchToChatView() { /* ... (no changes) ... */
        if (initialView) initialView.classList.add('hidden');
        if (chatView) chatView.classList.remove('hidden');
        if (reasonButton) reasonButton.style.display = 'inline-flex';
        if (reasonUsageDisplay) reasonUsageDisplay.style.display = 'inline';
        if (currentChatId && chats[currentChatId]) { updateModelNotification(chats[currentChatId].model); }
        else if (modelSelector) { updateModelNotification(modelSelector.value); }
        updateMaxUI(); // Show/hide upgrade link
    }

    function switchToInitialView() { /* ... (no changes) ... */
        if (initialView) initialView.classList.remove('hidden');
        if (chatView) chatView.classList.add('hidden');
        if (reasonButton) reasonButton.style.display = 'none';
        if (reasonUsageDisplay) reasonUsageDisplay.style.display = 'none';
        if (modelNotificationDiv) modelNotificationDiv.style.display = 'none';
        currentChatId = null;
        saveCurrentChatId();
        currentChatSession = null;
        if (chatMessagesContainer) chatMessagesContainer.innerHTML = '';
        updateActiveChatListItem();
        togglePersonalitySelector(false);
        if (modelSelector) modelSelector.value = loadSelectedModelPreference();
        deactivateReasonMode();
        removeSelectedImage();
        if (upgradeLink) upgradeLink.style.display = 'none'; // Hide upgrade link too
    }

    function renderChatList() { /* ... (no changes) ... */
        if (!chatListUl) return;
        chatListUl.innerHTML = '';
        const sortedChatIds = Object.keys(chats).sort((a, b) => {
            const timeA = parseInt(a.split('_')[1] || '0');
            const timeB = parseInt(b.split('_')[1] || '0');
            return timeB - timeA;
        });
        sortedChatIds.forEach(chatId => {
            const chatData = chats[chatId];
            if (!chatData) return;
            const li = document.createElement('li');
            li.classList.add('chat-list-item');
            li.dataset.chatId = chatId;
            const titleText = chatData.title || `Chat ${chatId.substring(chatId.length - 5)}`;
            li.textContent = titleText;
            li.title = titleText;
            if (chatId === currentChatId) { li.classList.add('active'); }
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-chat-btn');
            deleteBtn.innerHTML = '&times;';
            deleteBtn.title = "Delete Chat";
            deleteBtn.onclick = (event) => { event.stopPropagation(); handleDeleteChat(chatId); };
            li.appendChild(deleteBtn);
            li.addEventListener('click', () => { handleSelectChat(chatId); });
            chatListUl.appendChild(li);
        });
    }

    function updateActiveChatListItem() { /* ... (no changes) ... */
        if (!chatListUl) return;
        const items = chatListUl.querySelectorAll('.chat-list-item');
        items.forEach(item => { item.classList.toggle('active', item.dataset.chatId === currentChatId); });
    }

    function togglePersonalitySelector(show) { /* ... (no changes) ... */
        if (personalitySelectorContainer) {
            personalitySelectorContainer.classList.toggle('visible', show);
            if (personalitySelector) personalitySelector.disabled = !show;
        }
    }

    function updateModelNotification(selectedModelName) { /* ... (no changes) ... */
        if (!modelNotificationDiv) return;
        if (selectedModelName === GLOBAL_SHEETS_MODEL_NAME) {
            modelNotificationDiv.textContent = 'This model is optimized for Global Sheets...';
            modelNotificationDiv.style.display = 'block';
        } else {
            modelNotificationDiv.style.display = 'none';
        }
    }

    function deactivateReasonMode() { /* ... (no changes) ... */
        isReasonModeActive = false;
        if (reasonButton) { reasonButton.classList.remove('active'); }
        updateReasonButtonState();
    }

    // --- Image Handling ---
    function fileToBase64(file) { /* ... (no changes) ... */
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => { const base64String = reader.result.split(',')[1]; resolve(base64String); };
            reader.onerror = error => reject(error);
        });
    }
    async function handleImageSelection(event) { /* ... (no changes) ... */
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) { alert("Please select a valid image file..."); imageUploadInput.value = ''; return; }
        const maxSizeMB = 4;
        if (file.size > maxSizeMB * 1024 * 1024) { alert(`Image size exceeds ${maxSizeMB}MB limit.`); imageUploadInput.value = ''; return; }
        try {
            selectedImageData = await fileToBase64(file);
            selectedImageMimeType = file.type;
            if (selectedImagePreviewUrl) { URL.revokeObjectURL(selectedImagePreviewUrl); }
            selectedImagePreviewUrl = URL.createObjectURL(file);
            displayImagePreview(selectedImagePreviewUrl);
        } catch (error) { console.error("Error processing image:", error); alert("Error processing image..."); removeSelectedImage(); }
     }
    function displayImagePreview(imageUrl) { /* ... (no changes) ... */
        if (imagePreview && imagePreviewArea) { imagePreview.src = imageUrl; imagePreviewArea.style.display = 'inline-block'; }
    }
    function removeSelectedImage() { /* ... (no changes) ... */
        selectedImageData = null; selectedImageMimeType = null;
        if (selectedImagePreviewUrl) { URL.revokeObjectURL(selectedImagePreviewUrl); selectedImagePreviewUrl = null; }
        if (imagePreviewArea) { imagePreviewArea.style.display = 'none'; }
        if (imagePreview) { imagePreview.src = '#'; }
        if (imageUploadInput) { imageUploadInput.value = ''; }
        console.log("Selected image removed.");
    }


    // --- AI Interaction and Chat Management ---

    async function initializeAICurrentChat() {
         if (isInitializing) { console.warn("AI Initialization already in progress."); return; }
        isInitializing = true;
        console.log(`Attempting to initialize AI for chat: ${currentChatId}`);

        // Show chat loader immediately
        if (chatLoader) chatLoader.style.display = 'flex';
        if (chatMessagesContainer) chatMessagesContainer.innerHTML = ''; // Clear previous messages to show loader properly
        // Add chat loader back to container if it was removed
        if (chatLoader && !chatMessagesContainer.contains(chatLoader)) {
             chatMessagesContainer.appendChild(chatLoader);
        }

        if (!currentChatId || !chats[currentChatId]) {
            console.log("No active chat selected or chat data missing. Switching to initial view.");
            switchToInitialView(); // This will hide the chat view including the loader
            isInitializing = false;
            if (chatLoader) chatLoader.style.display = 'none'; // Ensure loader is hidden
            return;
        }

        const chatData = chats[currentChatId];
        const fakeModelNameToUse = chatData.model || loadSelectedModelPreference();
        const personalityToUse = (fakeModelNameToUse === EXPERIMENTAL_MODEL_NAME) ? (chatData.personality || DEFAULT_PERSONALITY) : undefined;
        const historyToLoad = chatData.history || [];

        console.log(`Initializing AI for chat ${currentChatId} - Model: ${fakeModelNameToUse}, Personality: ${personalityToUse || 'N/A'}`);

        modelSelector.value = fakeModelNameToUse;
        const showPersonality = fakeModelNameToUse === EXPERIMENTAL_MODEL_NAME;
        togglePersonalitySelector(showPersonality);
        if (showPersonality && personalityToUse) { personalitySelector.value = personalityToUse; }
        updateModelNotification(fakeModelNameToUse);

        // Disable inputs while loading
        if(messageInput) messageInput.disabled = true;
        if(sendButton) sendButton.disabled = true;
        deactivateReasonMode();
        removeSelectedImage();
        currentChatSession = null;

        try {
            // Check API Key only if NOT using a known local model
            const knownLocalModels = [GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME];
            if (!knownLocalModels.includes(fakeModelNameToUse)) {
                if (!API_KEY || API_KEY === "YOUR_GOOGLE_AI_API_KEY" || (API_KEY.startsWith("AIzaSyB") && API_KEY.length < 30)) {
                    throw new Error("Google AI API Key is missing, invalid, or a placeholder in the script.");
                }
                 if (!genAI) {
                    genAI = new GoogleGenerativeAI(API_KEY);
                    console.log("GoogleGenerativeAI client initialized.");
                }
            } else {
                 console.log("Local model selected, skipping Google AI Key check for initialization.");
            }

            // --- Simulate loading delay (optional, for testing loader) ---
            // await new Promise(resolve => setTimeout(resolve, 1000));
            // -----------------------------------------------------------

            // Hide loader and display content
            if (chatLoader) chatLoader.style.display = 'none';
            if (chatMessagesContainer.contains(chatLoader)) {
                 chatMessagesContainer.removeChild(chatLoader); // Remove loader element
            }

            // Display history OR welcome message
            if (historyToLoad.length > 0) {
                historyToLoad.forEach(message => {
                    displayMessage(message.parts, message.role, false, message.imagePreview || null);
                });
            } else {
                 // If history is empty, show the welcome message
                 console.log("Chat history empty, displaying welcome message.");
                 displayNewChatWelcome(chatMessagesContainer);
            }

            setTimeout(() => { if(chatMessagesContainer) chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight; }, 100);

            if(messageInput) messageInput.disabled = false;
            if(sendButton) sendButton.disabled = false;
            if(messageInput) messageInput.focus();
            updateReasonButtonState();
            updateMaxUI(); // Update Max UI elements

            console.log(`AI Initialized successfully for chat ${currentChatId}. Ready for interaction.`);

        } catch (error) {
            console.error(`Error initializing AI for chat ${currentChatId}:`, error);
            if (chatLoader) chatLoader.style.display = 'none'; // Hide loader on error
            if (chatMessagesContainer.contains(chatLoader)) {
                 chatMessagesContainer.removeChild(chatLoader); // Remove loader element
            }
            displayMessage(`AI Initialization Error: ${error.message}. Please check the API Key and console for details.`, 'bot', true);
            if(sendButton) sendButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
            if (reasonButton) reasonButton.disabled = true;
            // Keep inputs disabled on error
            if(messageInput) messageInput.disabled = true;
            if(sendButton) sendButton.disabled = true;
        } finally {
            isInitializing = false;
        }
    }


    /**
     * Main function to handle sending messages. Branches between Google AI and local model.
     */
    async function sendMessageInternal(messageText, isInitialMessage = false) {
        if ((!messageText && !selectedImageData) || currentThinkingIndicatorElement) {
            console.log("Send prevented: Empty message or thinking indicator active.");
            return;
        }

        let chatIdForMessage = currentChatId;
        let usedReasonModeForThisMessage = false;
        const imageToSend = selectedImageData;
        const imageMimeType = selectedImageMimeType;
        const imagePreviewForDisplay = selectedImagePreviewUrl;
        // REMOVED: let startTime = 0;

        // --- Clear Welcome Message if Present ---
        const welcomeContainer = chatMessagesContainer?.querySelector('.new-chat-welcome-container');
        if (welcomeContainer) {
            chatMessagesContainer.innerHTML = ''; // Clear welcome message
        }

        // --- Handle New Chat Creation ---
        if (!chatIdForMessage) {
            console.log(`No active chat. Creating new chat...`);
            const newChatId = generateChatId();
            const selectedModel = modelSelector.value;
            const selectedPersonality = (selectedModel === EXPERIMENTAL_MODEL_NAME) ? personalitySelector.value : undefined;
            chats[newChatId] = { history: [], model: selectedModel, title: "New Chat", personality: selectedPersonality };
            currentChatId = newChatId;
            chatIdForMessage = newChatId;
            console.log(`Created and activated new chat: ${currentChatId}`);
            saveCurrentChatId(); saveAllChats(); renderChatList(); updateActiveChatListItem();
            deactivateReasonMode();
            // Don't initialize AI here, just display user message. Init happens implicitly on first send if needed.
            // if (!isInitialMessage) { await initializeAICurrentChat(); } // This clears the container
            const userContentParts = [];
            if (messageText) userContentParts.push({ text: messageText });
            displayMessage(userContentParts.length > 0 ? userContentParts : [{text:"[Image Sent]"}], 'user', false, imagePreviewForDisplay);
            addMessageToCurrentChatHistory('user', userContentParts.length > 0 ? userContentParts : [{text: "[Image Sent]"}], imagePreviewForDisplay);
        } else {
            // --- Sending Message to Existing Chat ---
            if (isRateLimited()) return;
            messageTimestamps.push(Date.now());
            const userContentParts = [];
            if (messageText) userContentParts.push({ text: messageText });
            displayMessage(userContentParts.length > 0 ? userContentParts : [{text:"[Image Sent]"}], 'user', false, imagePreviewForDisplay);
            addMessageToCurrentChatHistory('user', userContentParts.length > 0 ? userContentParts : [{text: "[Image Sent]"}], imagePreviewForDisplay);
        }

        removeSelectedImage(); // Clear image state after displaying/saving

        // --- Prepare for AI Call ---
        if (!chatIdForMessage || !chats[chatIdForMessage]) { /* ... error handling ... */ return; }

        const currentChat = chats[chatIdForMessage];
        const selectedModelName = currentChat.model;
        const knownLocalModels = [GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME];

        // --- Disable Inputs ---
        if (messageInput) messageInput.disabled = true;
        if (sendButton) sendButton.disabled = true;
        if (initialSendButton) initialSendButton.disabled = true;
        if (reasonButton) reasonButton.disabled = true;
        if (imageUploadButton) imageUploadButton.disabled = true;
        if (micButton) micButton.disabled = true; // Disable mic button

        // ======================================================
        // BRANCH: Check if using a Local Model (Max or Unhinged)
        // ======================================================
        if (knownLocalModels.includes(selectedModelName)) {
            console.log(`Local model selected: ${selectedModelName}.`);

            // Subscription check ONLY for the Max Pro model
            if (selectedModelName === GRAXYBOT_MAX_MODEL_NAME && !isMaxUser) {
                console.log("User is not subscribed to Max.");
                displayMessage(`The ${GRAXYBOT_MAX_MODEL_NAME} model requires a Graxybot Max subscription. Click 'Upgrade to Max' above to learn more.`, 'bot', true);
                addMessageToCurrentChatHistory('model', [{ text: `[Blocked: Max subscription required for ${GRAXYBOT_MAX_MODEL_NAME}]` }]);
                // Re-enable inputs
                if (messageInput) messageInput.disabled = false;
                if (sendButton) sendButton.disabled = false;
                if (initialSendButton) initialSendButton.disabled = false;
                if (imageUploadButton) imageUploadButton.disabled = false;
                if (micButton) micButton.disabled = false; // Re-enable mic button
                updateReasonButtonState(); // Update reason button state
                updateMaxUI(); // Ensure upgrade link is shown
                return; // Stop processing
            }

            console.log(`Calling local model: ${selectedModelName}...`);
            // Determine indicator type based on model
            const indicatorType = selectedModelName === GRAXYBOT_MAX_MODEL_NAME ? 'local' : 'unhinged';
            showThinkingIndicator(indicatorType); // Show appropriate local thinking indicator
            let botMessageElement = null; // Define here for access in finally block

            try {
                // Add instruction to the prompt for the local model
                const promptForLocal = `User query: ${messageText || "Describe the image."}\n\n(Provide only the final response without explaining your reasoning.)`;

                const response = await fetch(`${LOCAL_MODEL_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // Send the selected model name to the backend
                    body: JSON.stringify({ message: promptForLocal, model: selectedModelName })
                });

                removeThinkingIndicator(); // Remove indicator once fetch starts responding

                if (!response.ok) {
                    throw new Error(`Local server request failed with status ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data && data.response) {
                    const botResponseText = data.response;
                    // Display the response
                    botMessageElement = displayMessage(botResponseText, 'bot'); // Get the created element
                    if (botMessageElement) {
                        const botMsgBubble = botMessageElement.querySelector('.message-bubble');
                        const botMsgParagraph = botMsgBubble?.querySelector('p[data-stream-target="true"]');
                        if (botMsgParagraph) {
                            const hasCode = processAndAppendText(botResponseText, botMsgParagraph);
                             // Add timestamp
                            const timestampSpan = document.createElement('span');
                            timestampSpan.classList.add('timestamp');
                            timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            botMsgBubble.appendChild(timestampSpan);

                            // REMOVED: Thought Timer logic

                            // Highlight code if present
                            if (hasCode && window.Prism) {
                                setTimeout(() => Prism.highlightAllUnder(botMsgBubble), 0);
                            }
                        }
                    }
                    addMessageToCurrentChatHistory('model', [{ text: botResponseText }]);
                } else {
                    throw new Error("Invalid response format received from local server.");
                }

            } catch (error) {
                console.error("Error calling local model:", error);
                removeThinkingIndicator(); // Ensure indicator is removed on error
                displayMessage(`Sorry, could not connect to the local ${selectedModelName} model. Error: ${error.message}`, 'bot', true);
                addMessageToCurrentChatHistory('model', [{ text: `[Error calling local model ${selectedModelName}: ${error.message}]` }]);
            } finally {
                // --- Cleanup after local model call ---
                removeThinkingIndicator(); // Ensure removed finally
                deactivateReasonMode();
                if (messageInput) messageInput.disabled = false;
                if (sendButton) sendButton.disabled = false;
                if (initialSendButton) initialSendButton.disabled = false;
                if (imageUploadButton) imageUploadButton.disabled = false;
                if (micButton) micButton.disabled = false; // Re-enable mic button
                updateReasonButtonState();
                updateMaxUI();
                if (messageInput && !messageInput.disabled) messageInput.focus();
            }

        // ======================================================
        // BRANCH: Using Google AI Models
        // ======================================================
        } else {
            let modelToUseGoogle = modelMapping[selectedModelName];
            let personality = (selectedModelName === EXPERIMENTAL_MODEL_NAME) ? currentChat.personality : undefined;
            // Use system prompt with instruction to hide thinking
            let systemPromptForSendGoogle = getSystemPrompt(selectedModelName, personality, false);
            let isReasoningGoogle = false;

            // Check Reason Mode for Google AI
            if (isReasonModeActive) {
                const currentUsage = getReasonUsage();
                if (currentUsage < MAX_REASON_USES_PER_DAY) {
                    console.log("Reason mode active for Google AI call.");
                    modelToUseGoogle = REASON_MODE_MODEL;
                    usedReasonModeForThisMessage = true;
                    isReasoningGoogle = true;
                    // Update system prompt for Reason mode (still includes hide thinking instruction)
                    systemPromptForSendGoogle = getSystemPrompt(selectedModelName, undefined, true);
                } else {
                     console.warn("Reason mode active, but daily limit reached. Sending with standard Google model.");
                    displayMessage(`Reason mode daily limit (${MAX_REASON_USES_PER_DAY}) reached. Using standard model instead.`, 'bot', true);
                    deactivateReasonMode();
                }
            }

            // Handle Reason Mode Delay for Google AI
            if (usedReasonModeForThisMessage) {
                // startTime = Date.now(); // Start timer for reason mode delay + API call
                showThinkingIndicator('reason'); // Show reason thinking indicator
                const delay = Math.random() * (MAX_REASON_DELAY_MS - MIN_REASON_DELAY_MS) + MIN_REASON_DELAY_MS;
                console.log(`Reason mode (Google AI): Simulating thinking for ${Math.round(delay / 1000)}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                if (!currentThinkingIndicatorElement) { /* ... abort logic ... */ return; }
                console.log("Reason mode (Google AI): Thinking complete.");
                // Keep indicator until API call finishes
            } else {
                 // startTime = Date.now(); // Start timer just before API call
            }

            // Construct Content Parts for Google AI
            const contentPartsGoogle = [];
            if (messageText) contentPartsGoogle.push({ text: messageText });
            if (imageToSend && imageMimeType) {
                contentPartsGoogle.push({ inline_data: { mime_type: imageMimeType, data: imageToSend } });
            } else if (!messageText && imageToSend) {
                contentPartsGoogle.push({ text: "Describe this image." });
            }

            // --- Send to Google AI (Streaming) ---
            let botMessageElement = null, botMessageBubble = null, botMessageParagraph = null;
            let fullResponseText = "", hasCodeInResponse = false;

            try {
                if (!genAI) { throw new Error("Google AI Client not initialized."); }
                const modelInstance = genAI.getGenerativeModel({ model: modelToUseGoogle, safetySettings });
                console.log(`Sending content stream request to Google AI model: ${modelToUseGoogle}`);

                const mainHistory = currentChat?.history || [];
                const historyForAPI = mainHistory.slice(-10).filter(msg => msg.role === 'user' || msg.role === 'model').map(msg => ({ role: msg.role, parts: msg.parts }));

                const streamResult = await modelInstance.generateContentStream({
                    contents: [...historyForAPI, { role: "user", parts: contentPartsGoogle }],
                    systemInstruction: { role: "system", parts: [{ text: systemPromptForSendGoogle }] }
                });

                // Remove thinking indicator *before* creating the message bubble
                removeThinkingIndicator();

                botMessageElement = displayMessage('', 'bot');
                if (botMessageElement) {
                    botMessageBubble = botMessageElement.querySelector('.message-bubble');
                    botMessageParagraph = botMessageBubble?.querySelector('p[data-stream-target="true"]');
                }
                if (!botMessageParagraph) { throw new Error("Could not find target paragraph for streaming."); }

                for await (const chunk of streamResult.stream) {
                    const blockReason = chunk.promptFeedback?.blockReason;
                    if (blockReason) { /* ... handle block ... */ fullResponseText = `[Response blocked: ${blockReason}]`; break; }
                    try {
                        const chunkText = chunk.text();
                        fullResponseText += chunkText;
                        botMessageParagraph.innerHTML += chunkText.replace(/\n/g, '<br>');
                        chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
                    } catch (error) { /* ... handle chunk error ... */ }
                }
                // const endTime = Date.now(); // End timer after stream finishes
                console.log("Google AI Streaming finished.");

                if (!fullResponseText.startsWith("[Response blocked")) {
                    hasCodeInResponse = processAndAppendText(fullResponseText, botMessageParagraph);
                    if (botMessageBubble) { /* ... add timestamp ... */
                        const timestampSpan = document.createElement('span');
                        timestampSpan.classList.add('timestamp');
                        timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        bubbleDiv.appendChild(timestampSpan); // Append timestamp to bubble

                         // REMOVED: Thought Timer logic
                    }
                    if (hasCodeInResponse && window.Prism && botMessageBubble) {
                        setTimeout(() => Prism.highlightAllUnder(botMessageBubble), 0);
                    }
                }
                addMessageToCurrentChatHistory('model', [{ text: fullResponseText }]);
                if (usedReasonModeForThisMessage) { incrementReasonUsage(); }

            } catch (error) {
                console.error("Google AI Streaming API Error:", error);
                removeThinkingIndicator(); // Ensure indicator removed on error
                if (botMessageElement && botMessageElement.parentNode) { botMessageElement.parentNode.removeChild(botMessageElement); }
                let errMsg = `Sorry, error contacting Google AI: ${error.message}`;
                /* ... more specific error messages ... */
                displayMessage(errMsg, 'bot', true);
                addMessageToCurrentChatHistory('model', [{ text: `[Error generating response: ${error.message || 'Unknown'}]` }]);
            } finally {
                // --- Cleanup after Google AI call ---
                removeThinkingIndicator(); // Ensure removed finally
                deactivateReasonMode();
                if (messageInput) messageInput.disabled = false;
                if (sendButton) sendButton.disabled = false;
                if (initialSendButton) initialSendButton.disabled = false;
                if (imageUploadButton) imageUploadButton.disabled = false;
                if (micButton) micButton.disabled = false; // Re-enable mic button
                updateReasonButtonState();
                updateMaxUI();
                if (messageInput && !messageInput.disabled) messageInput.focus();
            }
        } // End of Google AI branch
    } // End of sendMessageInternal


    function sendMessage() { /* ... (no changes) ... */
        if (isInitializing || currentThinkingIndicatorElement) return;
        const messageText = messageInput.value.trim();
        const imageSelected = !!selectedImageData;
        if (messageText || imageSelected) { messageInput.value = ''; sendMessageInternal(messageText, false); }
    }

    async function handleInitialSendMessage() { /* ... (no changes) ... */
         if (isInitializing || currentThinkingIndicatorElement) return;
        const messageText = initialMessageInput.value.trim();
        initialMessageInput.value = '';
        if (!messageText) return;
        switchToChatView();
        await sendMessageInternal(messageText, true);
    }


    // --- Event Handlers ---

    function handleSelectChat(chatId) { /* ... (no changes) ... */
         if (chatId === currentChatId || isInitializing || currentThinkingIndicatorElement) { return; }
        console.log(`Selecting chat: ${chatId}`);
        currentChatId = chatId;
        saveCurrentChatId();
        updateActiveChatListItem();
        switchToChatView();
        deactivateReasonMode();
        initializeAICurrentChat();
    }

    /** Displays the welcome message and suggested prompts in the chat area */
    function displayNewChatWelcome(container) {
        if (!container) {
            console.error("Message container not found for welcome message.");
            return;
        }
        console.log("Displaying new chat welcome message.");
        container.innerHTML = ''; // Clear previous content

        const welcomeContainer = document.createElement('div');
        welcomeContainer.className = 'new-chat-welcome-container';

        const title = document.createElement('h1');
        title.className = 'welcome-title';
        title.textContent = 'Graxybot';
        welcomeContainer.appendChild(title);

        const promptsGrid = document.createElement('div');
        promptsGrid.className = 'suggested-prompts-grid';

        // --- Suggested Prompts ---
        const hour = new Date().getHours();
        let timeBasedGreeting = "How can I help you today?";
        if (hour < 12) {
            timeBasedGreeting = "How's your morning? Coffee and Graxybot time?";
        } else if (hour < 18) {
            timeBasedGreeting = "Good afternoon! What can I help you achieve?";
        } else {
            timeBasedGreeting = "Good evening! Ready to wrap up the day or start something new?";
        }

        const suggestions = [
            timeBasedGreeting,
            "Explain quantum computing in simple terms.",
            "Write a short story about a robot who dreams.",
            "Give me some ideas for a healthy dinner.",
        ];

        suggestions.forEach(text => {
            const btn = document.createElement('button');
            btn.className = 'prompt-button';
            btn.textContent = text;
            btn.onclick = () => {
                if (messageInput) {
                    messageInput.value = text;
                    messageInput.focus();
                    // Optional: Automatically send the message when a suggestion is clicked
                    // sendMessage();
                }
            };
            promptsGrid.appendChild(btn);
        });

        welcomeContainer.appendChild(promptsGrid);
        container.appendChild(welcomeContainer); // Append the welcome structure
    }


    function handleNewChat() {
        console.log("New chat requested via button.");
        if (isInitializing || currentThinkingIndicatorElement) return;

        currentChatId = null; // Clear the active chat ID
        saveCurrentChatId();
        currentChatSession = null;

        switchToChatView(); // Switch to the main chat view layout
        updateActiveChatListItem(); // Deactivate any item in sidebar

        // Display the welcome message instead of clearing
        console.log("Calling displayNewChatWelcome from handleNewChat");
        displayNewChatWelcome(chatMessagesContainer);

        // Reset input fields and buttons
        if(messageInput) {
            messageInput.value = '';
            messageInput.disabled = false;
            messageInput.placeholder = "Message Graxybot...";
        }
        if(sendButton) sendButton.disabled = false;

        // Set model selector to the global preference
        const preferredModel = loadSelectedModelPreference();
        if(modelSelector) modelSelector.value = preferredModel;

        // Show/hide and set personality based on the preferred model
        const showPersonality = preferredModel === EXPERIMENTAL_MODEL_NAME;
        togglePersonalitySelector(showPersonality);
        if (showPersonality && personalitySelector) {
            personalitySelector.value = DEFAULT_PERSONALITY;
        }
        updateModelNotification(preferredModel);

        // Deactivate reason mode and clear image
        deactivateReasonMode();
        removeSelectedImage();
        updateMaxUI(); // Update Max UI for new chat screen

        if(messageInput) messageInput.focus(); // Focus the input field
    }

    function handleDeleteChat(chatIdToDelete) { /* ... (no changes) ... */
        if (!chats[chatIdToDelete] || isInitializing || currentThinkingIndicatorElement) return;
        const chatTitle = chats[chatIdToDelete].title || `Chat ${chatIdToDelete.substring(chatIdToDelete.length - 5)}`;
        if (!confirm(`Are you sure you want to delete the chat "${chatTitle}"?`)) { return; }
        console.log(`Deleting chat: ${chatIdToDelete}`);
        const wasActive = (currentChatId === chatIdToDelete);
        if (wasActive) { removeThinkingIndicator(); }
        delete chats[chatIdToDelete];
        saveAllChats();
        if (wasActive) { handleNewChat(); } // Go to new chat welcome screen if active was deleted
        renderChatList();
    }

    function handleModelChange(event) {
        if (isInitializing || currentThinkingIndicatorElement) return;
        const selectedModel = event.target.value;
        console.log(`Model selected via UI: ${selectedModel}`);
        saveSelectedModelPreference(selectedModel);

        const showPersonality = selectedModel === EXPERIMENTAL_MODEL_NAME;
        togglePersonalitySelector(showPersonality);
        updateModelNotification(selectedModel);

        if (currentChatId && chats[currentChatId]) {
            console.log(`Updating model for current chat ${currentChatId} to ${selectedModel}`);
            chats[currentChatId].model = selectedModel;
            if (showPersonality) {
                chats[currentChatId].personality = personalitySelector.value || DEFAULT_PERSONALITY;
            } else {
                delete chats[currentChatId].personality;
            }
            saveAllChats();
            deactivateReasonMode();
            initializeAICurrentChat(); // Re-initialize which will clear messages or show welcome
        } else if (!currentChatId && chatView && !chatView.classList.contains('hidden')) {
             // If on the new chat welcome screen, just update selectors
            if (showPersonality && personalitySelector) personalitySelector.value = DEFAULT_PERSONALITY;
            deactivateReasonMode();
            // No need to re-initialize, welcome screen is already showing
        }
        updateMaxUI(); // Update Max UI based on potentially new preference
    }

    function handlePersonalityChange(event) { /* ... (no changes) ... */
        if (isInitializing || currentThinkingIndicatorElement) return;
        const selectedPersonality = event.target.value;
        console.log(`Personality selected: ${selectedPersonality}`);
        if (currentChatId && chats[currentChatId] && chats[currentChatId].model === EXPERIMENTAL_MODEL_NAME) {
            console.log(`Updating personality for current chat ${currentChatId} to ${selectedPersonality}`);
            chats[currentChatId].personality = selectedPersonality;
            saveAllChats();
            deactivateReasonMode();
            initializeAICurrentChat();
        }
    }

    function handleReasonButtonClick() { /* ... (no changes) ... */
        if (isInitializing || currentThinkingIndicatorElement) return;
        if (reasonButton.disabled && !isReasonModeActive) return;
        if (isReasonModeActive) { deactivateReasonMode(); console.log("Reason mode deactivated."); }
        else {
            const remainingUses = MAX_REASON_USES_PER_DAY - getReasonUsage();
            if (remainingUses > 0) {
                isReasonModeActive = true;
                reasonButton.classList.add('active');
                reasonButton.disabled = false;
                updateReasonButtonState();
                console.log("Reason mode activated.");
            } else { console.warn("Attempted to activate Reason mode with 0 uses."); }
        }
    }

    // --- Max Modal Logic ---
    function showMaxModal() {
        if (maxUpgradeModal) maxUpgradeModal.classList.add('visible');
    }
    function hideMaxModal() {
        if (maxUpgradeModal) maxUpgradeModal.classList.remove('visible');
    }
    function startMaxTrial() {
        console.log("Starting Max 'Trial'...");
        isMaxUser = true;
        saveMaxStatus(); // Save status to localStorage
        updateMaxUI(); // Update UI (hide upgrade link)
        hideMaxModal(); // Close the modal
        // Optionally, display a confirmation message
        displayMessage("Welcome to Graxybot Max! You now have access to all features.", 'bot');
        // Add history entry only if a chat is active
        if(currentChatId) {
            addMessageToCurrentChatHistory('model', [{ text: "[User upgraded to Max (Trial)]" }]);
        }
    }

    // --- Popup Logic ---
    function showPopup() { /* ... (no changes) ... */
        if (popupOverlay) popupOverlay.classList.add('visible');
    }
    function hidePopup() { /* ... (no changes) ... */
         if (popupOverlay) popupOverlay.classList.remove('visible');
    }

    // --- Voice Mode Functions ---

    /** Initialize Speech Recognition */
    function initializeSpeechRecognition() {
        if (!SpeechRecognition) {
            console.warn("Speech Recognition API not supported in this browser.");
            if(micButton) micButton.disabled = true; // Disable mic button if not supported
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = false; // Process single utterances
        recognition.lang = 'en-US'; // Set language
        recognition.interimResults = false; // Get final results only
        recognition.maxAlternatives = 1; // Get the best result

        recognition.onstart = () => {
            isListening = true;
            if(micButton) micButton.classList.add('listening');
            if(micButton) micButton.title = "Stop Listening";
            console.log("Voice recognition started.");
        };

        recognition.onresult = (event) => {
            const speechResult = event.results[0][0].transcript;
            console.log('Speech recognized:', speechResult);
            if (messageInput) {
                messageInput.value = speechResult; // Populate input field
                messageInput.focus();
                // Consider auto-sending here if desired: sendMessage();
            }
        };

        recognition.onspeechend = () => {
            stopListening(); // Stop recognition when user stops talking
        };

        recognition.onend = () => {
            stopListening(); // Ensure UI resets if stopped unexpectedly
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            stopListening();
            let errorMsg = `Speech error: ${event.error}`;
            if (event.error === 'no-speech') {
                errorMsg = "No speech detected. Please try again.";
            } else if (event.error === 'audio-capture') {
                errorMsg = "Microphone error. Check permissions and hardware.";
            } else if (event.error === 'not-allowed') {
                errorMsg = "Microphone access denied. Please allow access in browser settings.";
            }
            displayMessage(errorMsg, 'bot', true);
        };
    }

    /** Start or Stop Listening */
    function toggleListening() {
        if (!recognition) {
             console.error("Speech Recognition not initialized.");
             alert("Voice input is not supported or initialized correctly.");
             return;
        }
        if (isListening) {
            stopListening();
        } else {
            try {
                 // Stop any ongoing speech synthesis first
                 if (synthesis.speaking) {
                    synthesis.cancel();
                 }
                 recognition.start();
            } catch (err) {
                console.error("Error starting recognition:", err);
                // Attempt to handle common errors like 'not-allowed' which might occur later
                if (err.name === 'NotAllowedError' || err.message.includes('permission')) {
                     displayMessage("Microphone access denied. Please allow access in browser settings.", 'bot', true);
                } else {
                     displayMessage(`Could not start voice input: ${err.message}`, 'bot', true);
                }
                stopListening(); // Reset UI
            }
        }
    }

    /** Stop Listening and Reset UI */
    function stopListening() {
        if (recognition && isListening) {
            recognition.stop();
        }
        isListening = false;
        if(micButton) micButton.classList.remove('listening');
        if(micButton) micButton.title = "Start Voice Input";
        console.log("Voice recognition stopped.");
    }

    /** Speak Text using Speech Synthesis */
    function speakText(textToSpeak) {
        if (!synthesis) {
            console.warn("Speech Synthesis not supported.");
            return;
        }
        // Remove code blocks and potentially other markdown for cleaner speech
        const cleanedText = textToSpeak.replace(/```[\s\S]*?```/g, ' (Code block omitted) ').replace(/[*_`]/g, ''); // Remove code blocks and markdown chars

        // Cancel any previous speech first
        if (synthesis.speaking) {
            synthesis.cancel();
            console.log("Cancelled previous speech synthesis.");
            // Small delay before starting new speech after cancellation
            setTimeout(() => startSpeaking(cleanedText), 100);
        } else {
             startSpeaking(cleanedText);
        }
    }

    function startSpeaking(text) {
         if (!text || text.trim() === '' || text.startsWith('[Response blocked') || text.startsWith('[Error')) return; // Don't speak empty or error messages

         const utterance = new SpeechSynthesisUtterance(text);
         utterance.onerror = (event) => {
             console.error('Speech synthesis error:', event.error);
         };
         // Optional: Configure voice, rate, pitch
         // const voices = synthesis.getVoices();
         // utterance.voice = voices[/* desired voice index */];
         // utterance.rate = 1;
         // utterance.pitch = 1;
         synthesis.speak(utterance);
         console.log("Speaking:", text.substring(0, 50) + "...");
    }


    // --- Initialization Sequence ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded. Initializing Graxybot UI...");

        // --- Get References ---
        chatMessagesContainer = document.getElementById('chat-messages');
        messageInput = document.getElementById('message-input');
        sendButton = document.getElementById('send-button');
        rateLimitMessageDiv = document.getElementById('rate-limit-message');
        modelSelector = document.getElementById('model-selector');
        initialView = document.getElementById('initial-view');
        chatView = document.getElementById('chat-view');
        initialMessageInput = document.getElementById('initial-message-input');
        initialSendButton = document.getElementById('initial-send-button');
        sidebar = document.querySelector('.sidebar');
        newChatBtn = document.getElementById('new-chat-btn');
        chatListUl = document.getElementById('chat-list');
        personalitySelectorContainer = document.getElementById('personality-selector-container');
        personalitySelector = document.getElementById('personality-selector');
        reasonButton = document.getElementById('reason-button');
        reasonUsageDisplay = document.getElementById('reason-usage-display');
        imageUploadButton = document.getElementById('image-upload-button');
        imageUploadInput = document.getElementById('image-upload-input');
        imagePreviewArea = document.getElementById('image-preview-area');
        imagePreview = document.getElementById('image-preview');
        removeImageButton = document.getElementById('remove-image-button');
        modelNotificationDiv = document.getElementById('model-notification');
        popupOverlay = document.getElementById('popupOverlay');
        closePopupButton = document.getElementById('closePopupButton');
        upgradeLink = document.getElementById('upgradeLink');
        maxUpgradeModal = document.getElementById('maxUpgradeModal');
        modalCloseBtn = document.getElementById('modalCloseBtn');
        startTrialBtn = document.getElementById('startTrialBtn');
        initialLoader = document.getElementById('initial-loader'); // Get initial loader
        chatLoader = document.getElementById('chat-loader'); // Get chat loader
        micButton = document.getElementById('mic-button'); // Get mic button

        // --- Validate Elements ---
        const essentialElements = { chatMessagesContainer, messageInput, sendButton, rateLimitMessageDiv, modelSelector, initialView, chatView, initialMessageInput, initialSendButton, sidebar, newChatBtn, chatListUl, personalitySelectorContainer, personalitySelector, reasonButton, reasonUsageDisplay, imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton, modelNotificationDiv, popupOverlay, closePopupButton, upgradeLink, maxUpgradeModal, modalCloseBtn, startTrialBtn, initialLoader, chatLoader, micButton };
        let missingElement = false;
        for (const key in essentialElements) {
            if (!essentialElements[key]) { console.error(`Fatal Error: UI element not found: ${key}`); missingElement = true; }
        }
        if (missingElement) { /* ... show error and return ... */
             document.body.innerHTML = "<p style='color: red; padding: 20px;'>Error: UI failed to load. Check console.</p>"; return;
        }
        console.log("All essential DOM elements found.");

        // --- Load Data & Set Initial State ---
        loadMaxStatus(); // Load subscription status FIRST
        chats = loadAllChats();
        currentChatId = loadCurrentChatId();
        const preferredModel = loadSelectedModelPreference();
        if(modelSelector) modelSelector.value = preferredModel;
        updateReasonButtonState();
        if(reasonButton) reasonButton.style.display = 'none';
        if(reasonUsageDisplay) reasonUsageDisplay.style.display = 'none';
        if(modelNotificationDiv) modelNotificationDiv.style.display = 'none';
        renderChatList();
        updateMaxUI(); // Update UI based on loaded Max status

        // --- Initialize Speech Recognition ---
        initializeSpeechRecognition();

        // --- Check API Key & Determine Initial View ---
        // Check only needed if the preferred/loaded model is NOT a known local one
        const knownLocalModels = [GRAXYBOT_MAX_MODEL_NAME, GRAXYBOT_UNHINGED_MODEL_NAME];
        const initialModelRequiresKey = !knownLocalModels.includes(preferredModel) && (!currentChatId || !chats[currentChatId] || !knownLocalModels.includes(chats[currentChatId].model));

        if (initialModelRequiresKey && (!API_KEY || API_KEY === "YOUR_GOOGLE_AI_API_KEY" || (API_KEY.startsWith("AIzaSyB") && API_KEY.length < 30))) {
             // API Key is missing or appears invalid for Google AI models
            console.warn("Google AI API Key missing/invalid. Google models disabled.");
            const warningMsg = "Configure Google AI API Key in script to use non-Max models.";
            if(initialView && !initialView.classList.contains('hidden')) { if(initialMessageInput) initialMessageInput.placeholder = "Google API Key needed!"; }
            else if (chatMessagesContainer) { displayMessage(warningMsg, 'bot', true); }
            // Disable elements if needed, but allow Max/Unhinged model usage
             if(modelSelector) {
                 // Disable non-Max/Unhinged options if key is missing? Or just let init fail? Let init fail.
             }
             if(reasonButton) reasonButton.disabled = true; // Reason uses Google Pro

             if (!currentChatId || !chats[currentChatId]) { switchToInitialView(); }
             else { switchToChatView(); initializeAICurrentChat(); } // Init will show error if Google model selected
        } else {
            // API Key present OR starting with local model - proceed normally
            console.log("API Key present or local model selected. Proceeding.");
            if (currentChatId && chats[currentChatId]) {
                console.log(`Restoring active chat: ${currentChatId}`);
                switchToChatView();
                initializeAICurrentChat();
            } else {
                console.log("No active chat found. Showing initial view.");
                switchToInitialView();
                if(initialMessageInput) initialMessageInput.focus();
            }
        }

        // --- Attach Event Listeners ---
        console.log("Attaching event listeners...");
        sendButton?.addEventListener('click', sendMessage);
        messageInput?.addEventListener('keypress', (event) => { /* ... send on Enter ... */
             if (event.key === 'Enter' && !event.shiftKey && !sendButton?.disabled && !currentThinkingIndicatorElement) { event.preventDefault(); sendMessage(); }
        });
        initialSendButton?.addEventListener('click', handleInitialSendMessage);
        initialMessageInput?.addEventListener('keypress', (event) => { /* ... send on Enter ... */
             if (event.key === 'Enter' && !event.shiftKey && !initialSendButton?.disabled && !currentThinkingIndicatorElement) { event.preventDefault(); handleInitialSendMessage(); }
        });
        modelSelector?.addEventListener('change', handleModelChange);
        personalitySelector?.addEventListener('change', handlePersonalityChange);
        newChatBtn?.addEventListener('click', handleNewChat);
        reasonButton?.addEventListener('click', handleReasonButtonClick);
        imageUploadButton?.addEventListener('click', () => { if (!imageUploadButton.disabled) { imageUploadInput?.click(); } });
        imageUploadInput?.addEventListener('change', handleImageSelection);
        removeImageButton?.addEventListener('click', removeSelectedImage);
        closePopupButton?.addEventListener('click', hidePopup);
        popupOverlay?.addEventListener('click', (event) => { if (event.target === popupOverlay) { hidePopup(); } });
        micButton?.addEventListener('click', toggleListening); // Add listener for mic button

        // Max Modal Listeners
        upgradeLink?.addEventListener('click', showMaxModal);
        modalCloseBtn?.addEventListener('click', hideMaxModal);
        startTrialBtn?.addEventListener('click', startMaxTrial);
        maxUpgradeModal?.addEventListener('click', (event) => { if (event.target === maxUpgradeModal) { hideMaxModal(); } }); // Close on overlay click

        // --- Show Update Popup ---
        showPopup();

        // --- Hide Initial Loader ---
        if(initialLoader) {
            initialLoader.classList.add('hidden');
            console.log("Initial loader hidden.");
        }

        console.log("Event listeners attached. Graxybot initialization complete.");
    });

</script>

</body>
</html>
