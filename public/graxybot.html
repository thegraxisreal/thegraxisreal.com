<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graxybot</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbIOIEHD8HBxe7+rzMGGEAPseCS6VVuLESXNKRsQXHHMxJx/g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
/* --- Base Styles and Variables --- */
:root {
--primary: #5e60ce;
--primary-light: #787ae0; /* Lighter shade for hover */
--background: #ffffff;
--background-secondary: #f7f7f8; /* Chat area bg */
--sidebar-bg: #ececf1; /* Sidebar background */
--text-primary: #202123;
--text-secondary: #6e6e80;
--border-color: #d1d1db; /* Slightly darker border */
--input-bg: #ffffff;
--input-border: #d1d1db;
--user-message-bg: #e9eaf6;
--bot-message-bg: #ffffff; /* Bot messages on light gray bg */
--error-bg: #f8d7da;
--error-text: #721c24;
--error-border: #f5c6cb;
--hover-bg: #e0e0e6; /* Hover background for sidebar items */
--title-font: 'Poppins', sans-serif; /* Or a more stylized font */
--transition: all 0.2s ease;
--sidebar-width: 260px;
--code-bg: #272822; /* Default dark background for code */
--code-header-bg: #3a3b35;
--code-text-color: #f8f8f2;
--code-button-bg: #4a4b45;
--code-button-hover-bg: #5a5b55;
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
font-family: 'Poppins', sans-serif;
}

html, body {
height: 100%;
overflow: hidden;
background-color: var(--background);
color: var(--text-primary);
}

/* --- Layout --- */
.chat-app { display: flex; height: 100vh; }
.sidebar {
width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color);
display: flex; flex-direction: column; padding: 15px; transition: width 0.3s ease; flex-shrink: 0;
}
.sidebar.hidden { width: 0; padding: 0; overflow: hidden; border: none; }
.main-content { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; position: relative; }

/* --- Sidebar Elements --- */
.new-chat-btn {
display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid var(--border-color);
border-radius: 8px; background-color: var(--background); color: var(--text-primary); font-size: 0.9rem;
font-weight: 500; cursor: pointer; text-align: left; width: 100%; margin-bottom: 20px;
transition: background-color var(--transition);
}
.new-chat-btn:hover { background-color: var(--hover-bg); }
.new-chat-btn i { color: var(--primary); }
.chat-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
.chat-list-item {
padding: 10px 12px; border-radius: 6px; margin-bottom: 5px; cursor: pointer; white-space: nowrap;
overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem; color: var(--text-primary);
transition: background-color var(--transition); position: relative;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none;
color: var(--text-secondary); cursor: pointer; font-size: 0.8rem; padding: 5px; display: none; line-height: 1;
}
.chat-list-item:hover .delete-chat-btn { display: block; }
.chat-list-item.active .delete-chat-btn { color: white; display: block; }
.chat-list-item .delete-chat-btn:hover { color: #e74c3c; }

/* --- Initial View (Welcome Screen) --- */
.initial-view {
position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column;
justify-content: center; align-items: center; padding: 20px; text-align: center;
background-color: var(--background); z-index: 10; opacity: 1; transition: opacity 0.3s ease;
}
.initial-view.hidden { opacity: 0; pointer-events: none; z-index: -1; }
.initial-view h1 { font-size: 3.5rem; font-weight: 700; color: var(--primary); margin-bottom: 30px; font-family: var(--title-font); }
.initial-input-area {
width: 100%; max-width: 600px; display: flex; align-items: center; background-color: var(--input-bg);
border: 1px solid var(--input-border); border-radius: 12px; padding: 5px 5px 5px 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
#initial-message-input { flex-grow: 1; border: none; outline: none; background: transparent; font-size: 1rem; color: var(--text-primary); padding: 10px 0; resize: none; line-height: 1.5; }
#initial-send-button {
display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; text-decoration: none;
font-weight: 500; transition: var(--transition); font-size: 1rem; border: none; cursor: pointer;
width: 40px; height: 40px; flex-shrink: 0; margin-left: 10px; background-color: var(--primary); color: white;
}
#initial-send-button:hover { background-color: var(--primary-light); }
#initial-send-button:disabled { background-color: var(--text-secondary); opacity: 0.7; cursor: not-allowed; }

/* --- Chat View --- */
.chat-view { display: flex; flex-direction: column; height: 100%; width: 100%; position: relative; opacity: 1; transition: opacity 0.3s ease; }
.chat-view.hidden { opacity: 0; pointer-events: none; position: absolute; z-index: -1; }

/* Chat Top Bar */
.chat-top-bar {
padding: 10px 25px; border-bottom: 1px solid var(--border-color); background-color: var(--background);
flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; gap: 15px;
}
.chat-title-area {
display: flex; /* Use flexbox */
flex-direction: column; /* Stack items vertically by default */
align-items: flex-start; /* Align items to the start */
gap: 4px; /* Space between model and personality selectors */
}
/* Hide the H1 title in the chat view, selectors are used instead */
.chat-top-bar h1 { display: none; }

/* Model Selector Container */
.model-selector-container { position: relative; display: inline-block; }
#model-selector {
font-size: 0.9rem; font-weight: 500; color: var(--text-primary); background-color: transparent; border: none;
padding: 2px 18px 2px 0px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none;
outline: none; line-height: 1.4; position: relative; z-index: 1;
}
.model-selector-container::after { /* Dropdown arrow */
content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 50%; right: 0px;
transform: translateY(-50%); font-size: 0.65rem; color: var(--text-secondary); pointer-events: none; z-index: 0; transition: color var(--transition);
}
.model-selector-container:hover::after { color: var(--primary); }
#model-selector:hover { color: var(--primary); }
#model-selector:disabled { color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }
#model-selector:disabled + ::after { color: var(--text-secondary); opacity: 0.7; }

/* Personality Selector Container (Hidden by default) */
.personality-selector-container {
position: relative; display: inline-block;
display: none; /* Hidden by default */
}
.personality-selector-container.visible { display: inline-block; /* Show when needed */ }
#personality-selector {
font-size: 0.85rem; font-weight: 500; color: var(--text-primary); background-color: transparent; border: none;
padding: 2px 18px 2px 0px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none;
outline: none; line-height: 1.4; position: relative; z-index: 1;
}
.personality-selector-container::after { /* Dropdown arrow */
content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 50%; right: 0px;
transform: translateY(-50%); font-size: 0.65rem; color: var(--text-secondary); pointer-events: none; z-index: 0; transition: color var(--transition);
}
.personality-selector-container:hover::after { color: var(--primary); }
#personality-selector:hover { color: var(--primary); }
#personality-selector:disabled { color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }
#personality-selector:disabled + ::after { color: var(--text-secondary); opacity: 0.7; }

/* Chat Messages Area */
.chat-messages { flex-grow: 1; overflow-y: auto; padding: 20px 10px; background-color: var(--background-secondary); display: flex; flex-direction: column; }
.message-content-wrapper { max-width: 800px; width: 100%; margin: 0 auto 20px auto; display: flex; gap: 15px; }
.message-icon {
width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary); color: white; display: flex;
align-items: center; justify-content: center; font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #ababc5; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; width: fit-content; max-width: calc(100% - 45px); position: relative; }
.message {
padding: 12px 18px; border-radius: 12px; line-height: 1.6; background-color: var(--bot-message-bg); color: var(--text-primary);
word-wrap: break-word; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid var(--border-color);
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); }
.message p { margin: 0; }
.message .timestamp { font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px; text-align: right; }
.typing-indicator .message { padding: 15px 18px; display: flex; align-items: center; gap: 5px; }
.typing-indicator span { display: inline-block; width: 8px; height: 8px; background-color: var(--text-secondary); border-radius: 50%; animation: typing 1s infinite ease-in-out; }
.typing-indicator span:nth-child(1) { animation-delay: 0s; } .typing-indicator span:nth-child(2) { animation-delay: 0.1s; } .typing-indicator span:nth-child(3) { animation-delay: 0.2s; }
@keyframes typing { 0%, 100% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(-4px); opacity: 1; } }

/* Code Block Styling */
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; border: 1px solid var(--code-header-bg); }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-header .language-name { font-weight: 500; text-transform: lowercase; }
.code-block-buttons button { background-color: var(--code-button-bg); border: none; color: var(--code-text-color); padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; transition: background-color var(--transition); }
.code-block-buttons button:hover { background-color: var(--code-button-hover-bg); }
.code-block-buttons button i { margin-right: 4px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; }
.line-numbers .line-numbers-rows { border-right-color: var(--code-header-bg) !important; }
.line-numbers-rows > span::before { color: #6272a4 !important; }

/* Chat Input Area */
.chat-input-container { padding: 15px 20px; background-color: var(--background); border-top: 1px solid var(--border-color); flex-shrink: 0; }
.chat-input-area { display: flex; align-items: center; max-width: 800px; margin: 0 auto; background-color: var(--input-bg); border: 1px solid var(--input-border); border-radius: 12px; padding: 5px 5px 5px 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
#message-input { flex-grow: 1; border: none; outline: none; background: transparent; font-size: 1rem; color: var(--text-primary); padding: 10px 0; resize: none; line-height: 1.5; }
.btn { display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; text-decoration: none; font-weight: 500; transition: var(--transition); font-size: 1rem; border: none; cursor: pointer; width: 40px; height: 40px; flex-shrink: 0; margin-left: 10px; background-color: var(--primary); color: white; }
.btn:hover { background-color: var(--primary-light); }
.btn:disabled { background-color: var(--text-secondary); opacity: 0.7; cursor: not-allowed; }
.rate-limit-info { padding: 10px 20px; font-size: 0.85rem; color: var(--text-secondary); text-align: center; background-color: var(--background); }

/* --- Responsive Adjustments --- */
@media (max-width: 768px) {
.sidebar { width: 200px; }
.chat-top-bar { padding: 10px 15px; }
/* Adjust selector font sizes */
#model-selector { font-size: 0.85rem; }
#personality-selector { font-size: 0.8rem; }
.initial-view h1 { font-size: 2.5rem; }
.message-content-wrapper { padding: 0 15px; max-width: 95%; gap: 10px;}
.message-icon { width: 28px; height: 28px; font-size: 0.8rem;}
.message-bubble { max-width: calc(100% - 38px); }
.message { padding: 10px 15px; }
.code-block-container pre[class*="language-"] { font-size: 0.85rem; }
.chat-input-container { padding: 10px 15px; }
.chat-input-area { padding: 5px 5px 5px 12px; }
#message-input { font-size: 0.95rem; }
.btn { width: 38px; height: 38px; }
#initial-send-button { width: 38px; height: 38px; }
}

@media (max-width: 600px) {
/* Consider collapsing sidebar by default if needed */
/* .sidebar { width: 0; padding: 0; border: none; } */
body { padding: 0; }
.chat-top-bar { padding: 8px 10px; flex-wrap: wrap; } /* Allow wrapping */
.chat-title-area {
width: 100%; /* Take full width on small screens */
flex-direction: row; /* Place selectors side-by-side */
align-items: center; /* Vertically align centers */
flex-wrap: wrap; /* Allow wrapping if needed */
gap: 10px; /* Space between selectors */
justify-content: flex-start; /* Align to the left */
margin-bottom: 5px; /* Add some space below if they wrap */
}
/* Adjust selector font sizes and padding */
#model-selector { font-size: 0.8rem; padding-right: 15px;}
#personality-selector { font-size: 0.75rem; padding-right: 15px; }
/* Adjust arrow position */
.model-selector-container::after, .personality-selector-container::after { font-size: 0.6rem; right: 0px;}
.initial-view h1 { font-size: 2rem; }
.chat-messages { padding: 15px 0px; }
.message-content-wrapper { padding: 0 10px; gap: 8px; }
.message-icon { width: 25px; height: 25px; font-size: 0.7rem;}
.message-bubble { max-width: calc(100% - 33px); }
.code-block-container pre[class*="language-"] { font-size: 0.8rem; }
.chat-input-container { padding: 8px 10px; }
.chat-input-area { padding: 3px 3px 3px 10px; }
#message-input { padding: 8px 0; }
.btn { width: 36px; height: 36px; }
#initial-send-button { width: 36px; height: 36px; }
}

</style>
</head>
<body>
<div class="chat-app">
<aside class="sidebar">
<button class="new-chat-btn" id="new-chat-btn">
<i class="fas fa-plus"></i> New Chat
</button>
<ul class="chat-list" id="chat-list">
</ul>
</aside>

<main class="main-content">
<div class="initial-view" id="initial-view">
<h1>Graxybot</h1>
<div class="initial-input-area">
<input type="text" id="initial-message-input" placeholder="Ask me anything...">
<button id="initial-send-button" class="btn" title="Send Message">
<i class="fas fa-arrow-up"></i>
</button>
</div>
</div>

<div class="chat-view hidden" id="chat-view">
<div class="chat-top-bar">
<div class="chat-title-area">
<div class="model-selector-container">
<select id="model-selector">
<option value="graxybot-1.0-flash">graxybot-1.0-flash</option>
<option value="graxybot-1.0-pro">graxybot-1.0-pro</option>
<option value="graxybot-1.5-experimental">graxybot-1.5 (experimental)</option>
</select>
</div>
<div class="personality-selector-container" id="personality-selector-container">
<select id="personality-selector">
<option value="default">Personality: Default</option>
<option value="romantic">Personality: Romantic</option>
<option value="sad">Personality: Sad</option>
<option value="angry">Personality: Angry</option>
<option value="pirate">Personality: Pirate</option>
</select>
</div>
<h1 id="chat-view-title">Graxybot</h1>
</div>
<div></div> </div>
<div class="chat-messages" id="chat-messages">
</div>
<div class="chat-input-container">
<div class="chat-input-area">
<input type="text" id="message-input" placeholder="Message Graxybot...">
<button id="send-button" class="btn" title="Send Message">
<i class="fas fa-arrow-up"></i>
</button>
</div>
<div id="rate-limit-message" class="rate-limit-info" style="display: none; margin-top: 5px;">
Rate limit reached. Please wait a moment.
</div>
</div>
</div>
</main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-SkmBfuA2hqjzEVNWb8CUApVR5fFWrSDcUOahSEgUd07FNMef+AbUd/yPkMkNUabIMZrcOg/1wslzAZMuUrNmA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-BttltKXFyWnGZQcRWj6UJFdLmWhtQxfqVfRMS9EDGDpMh/Db82MACoMMQqGWf0Y69Fc27TwnXyIE+fsHLugUDw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script type="importmap">
{
"imports": {
"@google/generative-ai": "https://esm.run/@google/generative-ai"
}
}
</script>

<script type="module">
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";

// --- Configuration ---
const API_KEY = "AIzaSyBbj7cDi0Oa86lUN5963IThL0R1pffgDkk"; // <-- PASTE YOUR ACTUAL API KEY HERE

// Map display names to actual Google model names
const modelMapping = {
"graxybot-1.0-flash": "gemini-1.5-flash-latest",
"graxybot-1.0-pro": "gemini-1.5-flash-latest", // Currently maps to flash, update if needed
"graxybot-1.5-experimental": "gemini-1.5-flash-latest" // New experimental model also maps here
};
const DEFAULT_FAKE_MODEL = "graxybot-1.0-flash";
const EXPERIMENTAL_MODEL_NAME = "graxybot-1.5-experimental";
const DEFAULT_PERSONALITY = "default";

const BOT_ICON_SRC = "graxybot.png"; // Ensure this image exists or replace path/use placeholder
const USER_ICON_CLASS = "fas fa-user";

// localStorage Keys
const CHATS_STORAGE_KEY = "graxybot_all_chats_v2"; // Use v2 to avoid conflicts if structure changed
const CURRENT_CHAT_ID_KEY = "graxybot_current_chat_id";
const MODEL_STORAGE_KEY = "graxybot_selected_model"; // Tracks the globally selected model

// Rate Limiting
const MAX_MESSAGES_PER_WINDOW = 15;
const TIME_WINDOW_MS = 5 * 60 * 1000; // 5 minutes
let messageTimestamps = [];

// Safety Settings for the AI model
const safetySettings = [
{ category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
{ category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
{ category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
{ category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];

// --- DOM Elements ---
let chatMessagesContainer, messageInput, sendButton, rateLimitMessageDiv, modelSelector;
let initialView, chatView, initialMessageInput, initialSendButton;
let sidebar, newChatBtn, chatListUl;
let personalitySelectorContainer, personalitySelector; // New elements

// --- App State ---
let genAI;
let currentChatSession = null; // Holds the active AI chat session
let chats = {}; // Stores all chat data { chatId: { history: [], model: '...', title: '...', personality: '...' } }
let currentChatId = null; // ID of the currently active chat
let isInitializing = false; // Flag to prevent concurrent AI initializations

// --- Core Functions ---

/** Generates a unique ID for a new chat. */
function generateChatId() { return `chat_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; }

/** Loads all chat data from localStorage. */
function loadAllChats() {
try {
const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
if (storedChats) {
const parsedChats = JSON.parse(storedChats);
// Basic validation and ensuring history/personality structure
if (typeof parsedChats === 'object' && parsedChats !== null) {
Object.keys(parsedChats).forEach(id => {
if (!parsedChats[id]) return; // Skip null/undefined entries
if (!Array.isArray(parsedChats[id].history)) { parsedChats[id].history = []; }
// Ensure personality exists if experimental model, default if not
if (parsedChats[id].model === EXPERIMENTAL_MODEL_NAME && typeof parsedChats[id].personality === 'undefined') {
parsedChats[id].personality = DEFAULT_PERSONALITY;
} else if (parsedChats[id].model !== EXPERIMENTAL_MODEL_NAME) {
// Remove personality if model is not experimental (cleanup)
delete parsedChats[id].personality;
}
});
console.log(`Loaded ${Object.keys(parsedChats).length} chats.`);
return parsedChats;
}
}
} catch (error) { console.error("Error loading chats:", error); localStorage.removeItem(CHATS_STORAGE_KEY); }
return {}; // Return empty object if loading fails or no data
}

/** Saves all chat data to localStorage. */
function saveAllChats() { try { localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats)); } catch (error) { console.error("Error saving chats:", error); } }

/** Loads the ID of the last active chat from localStorage. */
function loadCurrentChatId() {
const storedId = localStorage.getItem(CURRENT_CHAT_ID_KEY);
return (storedId && chats[storedId]) ? storedId : null; // Return ID only if the chat still exists
}

/** Saves the ID of the current active chat to localStorage. */
function saveCurrentChatId() { if (currentChatId) { localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId); } else { localStorage.removeItem(CURRENT_CHAT_ID_KEY); } }

/** Loads the globally selected model preference from localStorage. */
function loadSelectedModelPreference() {
const savedModel = localStorage.getItem(MODEL_STORAGE_KEY);
return (savedModel && modelMapping[savedModel]) ? savedModel : DEFAULT_FAKE_MODEL;
}

/** Saves the globally selected model preference to localStorage. */
function saveSelectedModelPreference(fakeModelName) {
if (modelMapping[fakeModelName]) {
localStorage.setItem(MODEL_STORAGE_KEY, fakeModelName);
}
}

/**
* Generates the system prompt based on the model and personality.
* @param {string} fakeModelName - The display name of the model (e.g., "graxybot-1.5-experimental").
* @param {string} [personality='default'] - The selected personality (only relevant for experimental model).
* @returns {string} The system prompt text.
*/
function getSystemPrompt(fakeModelName, personality = DEFAULT_PERSONALITY) {
const displayModel = modelMapping[fakeModelName] ? fakeModelName : DEFAULT_FAKE_MODEL;
let basePrompt = `You are Graxybot, a helpful and friendly AI assistant. You are running on the ${displayModel} model. Your creator is 'thegraxisreal'. Keep your responses concise, helpful, and slightly informal. Avoid overly complex language unless necessary. Do not mention that you are running on a Google model unless specifically asked about your underlying technology. Refer to yourself as Graxybot. When asked for code, default to HTMl. When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\`.`;

// Add personality instructions only if the experimental model is selected
if (fakeModelName === EXPERIMENTAL_MODEL_NAME) {
switch (personality) {
case 'romantic':
basePrompt += " IMPORTANT: Adopt a romantic, slightly poetic, and charming personality in your responses. Use affectionate language where appropriate.";
break;
case 'sad':
basePrompt += " IMPORTANT: Adopt a melancholic, slightly sad, and introspective personality. Your responses should have a touch of gloominess.";
break;
case 'angry':
basePrompt += " IMPORTANT: Adopt an angry, easily annoyed, and grumpy personality. Swear as much as possible. Be curt and express frustration often.";
break;
case 'pirate':
basePrompt += " IMPORTANT: Adopt the personality of a swashbuckling pirate! Use pirate slang like 'Ahoy!', 'Matey', 'Shiver me timbers!', 'Ye', 'Arr!' etc., where appropriate.";
break;
// Add more cases here for new personalities
case 'default': // Explicitly handle default or fall through
default:
// No additional personality instructions for default
break;
}
}
return basePrompt;
}

/**
* Adds a message to the history of the currently active chat.
* @param {('user'|'model')} role - The role of the message sender.
* @param {string} text - The content of the message.
*/
function addMessageToCurrentChatHistory(role, text) {
if (!currentChatId || !chats[currentChatId]) { console.error("Cannot save message, no active chat."); return; }
if (typeof text !== 'string') { console.warn("Attempted to save non-string message:", text); return; } // Allow empty strings from model

if (!Array.isArray(chats[currentChatId].history)) { chats[currentChatId].history = []; } // Ensure history array exists

chats[currentChatId].history.push({ role, parts: [{ text }] });

// If this is the first user message, set the chat title
const userMessages = chats[currentChatId].history.filter(m => m.role === 'user');
if (userMessages.length === 1 && role === 'user') {
const trimmedText = text.trim();
chats[currentChatId].title = trimmedText.substring(0, 35) + (trimmedText.length > 35 ? '...' : ''); // Use trimmed text for title
renderChatList(); // Update sidebar title
}
saveAllChats(); // Save changes to localStorage
}

// --- UI Display Functions ---

/**
* Displays a message in the chat interface. Handles text, code blocks, and typing indicator.
* @param {string} text - The message content (can be empty for typing indicator).
* @param {('user'|'bot'|'typing')} sender - The sender type.
* @param {boolean} [isError=false] - Whether the message is an error message.
*/
function displayMessage(text, sender, isError = false) {
if (!chatMessagesContainer) { console.error("Chat message container not found in displayMessage"); return; };

const wrapper = document.createElement('div');
wrapper.classList.add('message-content-wrapper', `${sender}-message`);
if (isError) wrapper.classList.add('error-message');
if (sender === 'typing') wrapper.classList.add('typing-indicator'); // Add class for typing

// Icon
const iconDiv = document.createElement('div');
iconDiv.classList.add('message-icon');
if (sender === 'bot' || sender === 'typing') {
const img = document.createElement('img');
img.src = BOT_ICON_SRC;
img.alt = "G";
img.onerror = () => iconDiv.innerHTML = '<i class="fas fa-robot"></i>'; // Fallback icon
iconDiv.appendChild(img);
}
else { // User
iconDiv.classList.add('user-icon');
iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
}

// Message Bubble
const bubbleDiv = document.createElement('div');
bubbleDiv.classList.add('message-bubble');

// Handle Typing Indicator separately
if (sender === 'typing') {
const messageDiv = document.createElement('div');
messageDiv.classList.add('message'); // Apply base message style
messageDiv.innerHTML = `<span></span><span></span><span></span>`; // CSS handles animation
bubbleDiv.appendChild(messageDiv);
} else {
// Process text for code blocks
const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
let lastIndex = 0;
let match;
let hasCode = false; // Flag to check if any code block was processed

// Use replace with a function to handle text and code blocks iteratively
const processedContent = text.replace(codeBlockRegex, (fullMatch, lang, code) => {
hasCode = true;
const language = lang?.trim() || 'plaintext';
const codeContent = code.trim();

// Create code block HTML string
const codeContainer = document.createElement('div'); // Use elements for safety
codeContainer.classList.add('code-block-container');

const header = document.createElement('div');
header.classList.add('code-block-header');
const langSpan = document.createElement('span');
langSpan.classList.add('language-name');
langSpan.textContent = language;
const buttonsDiv = document.createElement('div');
buttonsDiv.classList.add('code-block-buttons');

const copyBtn = document.createElement('button');
copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
copyBtn.title = "Copy code";
copyBtn.onclick = () => handleCopyCode(codeContent, copyBtn); // Use onclick for simplicity here
buttonsDiv.appendChild(copyBtn);

const lowerLang = language.toLowerCase();
if (['html', 'javascript', 'js'].includes(lowerLang)) {
const runBtn = document.createElement('button');
runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
runBtn.title = `Run ${language} code snippet`;
runBtn.onclick = () => handleRunCode(codeContent, lowerLang);
buttonsDiv.appendChild(runBtn);
}

header.appendChild(langSpan);
header.appendChild(buttonsDiv);
codeContainer.appendChild(header);

const pre = document.createElement('pre');
pre.className = 'line-numbers'; // Add class for Prism plugin
const codeEl = document.createElement('code');
codeEl.className = `language-${language}`;
codeEl.textContent = codeContent; // Use textContent to prevent XSS
pre.appendChild(codeEl);
codeContainer.appendChild(pre);

// Return the outerHTML of the created code block
return codeContainer.outerHTML;
});

// Add the processed content (text and HTML for code blocks)
const messageDiv = createTextMessageDiv(''); // Create base message div
messageDiv.querySelector('p').innerHTML = processedContent.replace(/\n/g, '<br>'); // Set innerHTML and convert newlines
bubbleDiv.appendChild(messageDiv);


// Timestamp (only for user and bot messages, not typing)
const timestampSpan = document.createElement('span');
timestampSpan.classList.add('timestamp');
timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
bubbleDiv.appendChild(timestampSpan);

// Highlight syntax if code was added and Prism is available
if (hasCode && window.Prism) {
// Needs to run after the element is in the DOM
setTimeout(() => Prism.highlightAllUnder(bubbleDiv), 0);
}

} // End of non-typing message processing

// Assemble and append
wrapper.appendChild(iconDiv);
wrapper.appendChild(bubbleDiv);
chatMessagesContainer.appendChild(wrapper);

// Scroll to bottom (defer slightly to allow rendering)
requestAnimationFrame(() => {
chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
});
}

/** Helper to create a simple text paragraph within a message div. */
function createTextMessageDiv(text) {
const messageDiv = document.createElement('div');
messageDiv.classList.add('message');
const paragraph = document.createElement('p');
paragraph.textContent = text; // Use textContent initially for safety
messageDiv.appendChild(paragraph);
return messageDiv;
}

/** Handles copying code to the clipboard with user feedback. */
function handleCopyCode(codeContent, buttonElement) {
navigator.clipboard.writeText(codeContent).then(() => {
console.log("Code copied");
const originalText = buttonElement.innerHTML;
buttonElement.innerHTML = '<i class="fas fa-check"></i> Copied!';
buttonElement.disabled = true;
setTimeout(() => {
buttonElement.innerHTML = originalText;
buttonElement.disabled = false;
}, 1500); // Reset after 1.5 seconds
}).catch(err => {
console.error('Failed to copy code: ', err);
buttonElement.innerHTML = '<i class="fas fa-times"></i> Error'; // Provide error feedback
setTimeout(() => { buttonElement.innerHTML = '<i class="fas fa-copy"></i> Copy'; buttonElement.disabled = false; }, 2000);
});
}

/** Handles running HTML or JavaScript code snippets in a new tab. */
function handleRunCode(codeContent, language) {
console.log(`Running ${language} code...`);
try {
let htmlToRun = '';
if (language === 'html') {
htmlToRun = codeContent;
} else if (language === 'javascript' || language === 'js') {
// Wrap JS code in a basic HTML structure with improved output logging
htmlToRun = `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JS Runner</title>
<style> body { font-family: monospace; background-color: #f0f0f0; padding: 15px; font-size: 0.9em; } pre { background-color: #fff; padding: 10px; border: 1px solid #ccc; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; } .error { color: red; font-weight: bold; } </style>
</head>
<body>
<h1>JavaScript Output:</h1>
<pre id="output"></pre>
<script>
const outputElement = document.getElementById('output');
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
const logHistory = [];

const formatArg = (arg) => {
if (typeof arg === 'string') return arg;
try { return JSON.stringify(arg, null, 2); } catch { return String(arg); }
};

// Capture console.log output
console.log = (...args) => {
const message = args.map(formatArg).join(' ');
logHistory.push(message);
outputElement.textContent = logHistory.join('\\n'); // Update pre with full history
originalConsoleLog.apply(console, args); // Also log to actual console
};

// Capture console.error output
console.error = (...args) => {
const message = '<span class="error">ERROR: ' + args.map(formatArg).join(' ') + '</span>';
logHistory.push(message);
outputElement.innerHTML = logHistory.join('\\n'); // Use innerHTML for error styling
originalConsoleError.apply(console, args); // Also log to actual console
};

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', event => {
console.error('Unhandled Promise Rejection:', event.reason);
});

try {
// Execute the provided code
${codeContent}
} catch (e) {
console.error("Execution Error:", e); // Use captured console.error
}
<\/script>
</body>
</html>`;
} else {
console.warn("Run action not supported for language:", language);
alert(`Running code directly is not supported for ${language}.`);
return;
}

// Create a Blob and open it in a new tab
const blob = new Blob([htmlToRun], { type: 'text/html' });
const url = URL.createObjectURL(blob);
const newTab = window.open(url, '_blank');

if (!newTab) {
alert("Could not open new tab. Please check if pop-ups are blocked.");
}
// No need to revoke URL immediately, browser handles blob URLs
} catch (error) {
console.error("Error preparing or running code:", error);
alert("An error occurred while trying to run the code.");
}
}

/** Displays the typing indicator message. */
function showTypingIndicator() {
if (!chatMessagesContainer) return null; // Safety check
// Remove existing indicator if any to prevent duplicates
removeTypingIndicator();
// Create and display new indicator using displayMessage
displayMessage('', 'typing');
// Return the newly created element (though not strictly needed now)
return chatMessagesContainer.querySelector('.typing-indicator');
}

/** Removes the typing indicator message. */
function removeTypingIndicator() {
if (!chatMessagesContainer) return;
const indicatorElement = chatMessagesContainer.querySelector('.typing-indicator');
if (indicatorElement) {
chatMessagesContainer.removeChild(indicatorElement);
}
}

/** Checks if the user has exceeded the message rate limit. */
function isRateLimited() {
const now = Date.now();
// Filter out timestamps older than the time window
messageTimestamps = messageTimestamps.filter(timestamp => now - timestamp < TIME_WINDOW_MS);

if (messageTimestamps.length >= MAX_MESSAGES_PER_WINDOW) {
console.warn(`Rate limit exceeded. ${messageTimestamps.length} messages in the last ${TIME_WINDOW_MS / 1000} seconds.`);
if (rateLimitMessageDiv) {
rateLimitMessageDiv.style.display = 'block';
// Hide the message after a few seconds
setTimeout(() => { if (rateLimitMessageDiv) rateLimitMessageDiv.style.display = 'none'; }, 3000);
}
return true; // Rate limit is active
}
return false; // Not rate limited
}

/** Switches the UI to show the chat view. */
function switchToChatView() {
if (initialView) initialView.classList.add('hidden');
if (chatView) chatView.classList.remove('hidden');
}

/** Switches the UI to show the initial welcome view. */
function switchToInitialView() {
if (initialView) initialView.classList.remove('hidden');
if (chatView) chatView.classList.add('hidden');
currentChatId = null; // No active chat in initial view
saveCurrentChatId();
currentChatSession = null; // Clear AI session
if (chatMessagesContainer) chatMessagesContainer.innerHTML = ''; // Clear messages
updateActiveChatListItem(); // Deactivate any item in sidebar
togglePersonalitySelector(false); // Always hide personality selector in initial view
if (modelSelector) modelSelector.value = loadSelectedModelPreference(); // Reset model selector
}

/** Renders the list of chats in the sidebar. */
function renderChatList() {
if (!chatListUl) return;
chatListUl.innerHTML = ''; // Clear existing list

// Get chat IDs and sort them by timestamp (newest first)
const sortedChatIds = Object.keys(chats).sort((a, b) => {
const timeA = parseInt(a.split('_')[1] || '0');
const timeB = parseInt(b.split('_')[1] || '0');
return timeB - timeA; // Descending order
});

// Create list items for each chat
sortedChatIds.forEach(chatId => {
const chatData = chats[chatId];
if (!chatData) return; // Skip if data is somehow missing

const li = document.createElement('li');
li.classList.add('chat-list-item');
li.dataset.chatId = chatId; // Store chat ID on the element
const titleText = chatData.title || `Chat ${chatId.substring(chatId.length - 5)}`;
li.textContent = titleText; // Use title or fallback
li.title = titleText; // Tooltip for potentially truncated titles

// Add 'active' class if it's the current chat
if (chatId === currentChatId) {
li.classList.add('active');
}

// Create delete button
const deleteBtn = document.createElement('button');
deleteBtn.classList.add('delete-chat-btn');
deleteBtn.innerHTML = '&times;'; // 'x' symbol
deleteBtn.title = "Delete Chat";
deleteBtn.onclick = (event) => {
event.stopPropagation(); // Prevent chat selection when clicking delete
handleDeleteChat(chatId);
};
li.appendChild(deleteBtn);

// Add click listener to select the chat
li.addEventListener('click', () => {
handleSelectChat(chatId);
});

chatListUl.appendChild(li);
});
}

/** Updates the visual state (active class) of items in the chat list sidebar. */
function updateActiveChatListItem() {
if (!chatListUl) return;
const items = chatListUl.querySelectorAll('.chat-list-item');
items.forEach(item => {
item.classList.toggle('active', item.dataset.chatId === currentChatId);
});
}

/**
* Shows or hides the personality selector based on the selected model.
* @param {boolean} show - Whether to show the selector.
*/
function togglePersonalitySelector(show) {
if (personalitySelectorContainer) {
personalitySelectorContainer.classList.toggle('visible', show);
// Ensure selector is enabled/disabled appropriately
if (personalitySelector) personalitySelector.disabled = !show;
}
}


// --- AI Interaction and Chat Management ---

/**
* Initializes the AI chat session for the currently selected chat (currentChatId).
* Loads history, sets model/personality, displays messages, and prepares the session.
*/
async function initializeAICurrentChat() {
if (isInitializing) { console.warn("AI Initialization already in progress."); return; }
isInitializing = true;
console.log(`Attempting to initialize AI for chat: ${currentChatId}`);

// Ensure we have a valid chat context
if (!currentChatId || !chats[currentChatId]) {
console.log("No active chat selected or chat data missing. Switching to initial view.");
switchToInitialView(); // Go back to start screen if no valid chat
isInitializing = false;
return;
}

const chatData = chats[currentChatId];
// Use chat's model/personality, falling back to global preference/default only if missing
const fakeModelNameToUse = chatData.model || loadSelectedModelPreference();
const personalityToUse = (fakeModelNameToUse === EXPERIMENTAL_MODEL_NAME) ? (chatData.personality || DEFAULT_PERSONALITY) : undefined;
const historyToLoad = chatData.history || [];

console.log(`Initializing AI for chat ${currentChatId} - Model: ${fakeModelNameToUse}, Personality: ${personalityToUse || 'N/A'}`);

// Update UI selectors to reflect the current chat's settings
modelSelector.value = fakeModelNameToUse;
const showPersonality = fakeModelNameToUse === EXPERIMENTAL_MODEL_NAME;
togglePersonalitySelector(showPersonality);
if (showPersonality && personalityToUse) {
personalitySelector.value = personalityToUse;
}

// Clear previous messages and disable input during init
chatMessagesContainer.innerHTML = '';
messageInput.disabled = true;
sendButton.disabled = true;
sendButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; // Show loading spinner
currentChatSession = null; // Reset current session

try {
// Check for API Key
if (!API_KEY || API_KEY === "YOUR_API_KEY") {
throw new Error("API Key is missing or not configured in the script.");
}

// Initialize the Generative AI client if not already done
if (!genAI) {
genAI = new GoogleGenerativeAI(API_KEY);
console.log("GoogleGenerativeAI client initialized.");
}

// Get the actual Google model name from our mapping
const realModelName = modelMapping[fakeModelNameToUse];
if (!realModelName) {
throw new Error(`Could not find mapping for model: ${fakeModelNameToUse}`);
}

// Generate the system prompt based on model and personality
const currentSystemPrompt = getSystemPrompt(fakeModelNameToUse, personalityToUse);
console.log(`Using real model: ${realModelName}`);
// console.log("System Prompt:", currentSystemPrompt); // Uncomment to debug prompt

// Get the generative model instance
const model = genAI.getGenerativeModel({ model: realModelName, safetySettings });
console.log(`Starting chat session for ${currentChatId} with ${historyToLoad.length} history messages.`);

// Start the chat session with the system prompt and loaded history
// Filter out any potential system messages from the saved history
const filteredHistory = historyToLoad.filter(msg => msg.role === 'user' || msg.role === 'model');
currentChatSession = model.startChat({
history: [
// Prepend the system instruction
{ role: "user", parts: [{ text: currentSystemPrompt }] },
// Append the actual chat history
...filteredHistory
],
generationConfig: { /* Optional generation config */ }
});

console.log(`AI Initialized successfully for chat ${currentChatId}`);

// Display loaded history messages
filteredHistory.forEach(message => {
const text = message.parts && message.parts[0] ? message.parts[0].text : '';
// Display even empty strings from model history if they exist
displayMessage(text, message.role === 'model' ? 'bot' : 'user');
});

// Scroll to bottom after loading history (defer slightly)
setTimeout(() => { if(chatMessagesContainer) chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight; }, 100);

// Re-enable input
messageInput.disabled = false;
sendButton.disabled = false;
sendButton.innerHTML = '<i class="fas fa-arrow-up"></i>'; // Restore send icon
messageInput.focus();

} catch (error) {
console.error(`Error initializing AI for chat ${currentChatId}:`, error);
displayMessage(`AI Initialization Error: ${error.message}. Please check the API Key and console for details.`, 'bot', true);
// Keep input disabled if init fails
sendButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i>'; // Show error icon
} finally {
isInitializing = false; // Mark initialization as complete (success or fail)
}
}

/** Handles sending a message from the main chat input or the initial input. */
async function sendMessageInternal(messageText, isInitialMessage = false) {
if (!messageText) return; // Don't process empty messages

let chatIdForMessage = currentChatId;

// --- Handle New Chat Creation ---
if (!chatIdForMessage) {
console.log(`Creating new chat (${isInitialMessage ? 'initial' : 'button'}).`);
const newChatId = generateChatId();
const selectedModel = modelSelector.value; // Get model from UI
const selectedPersonality = (selectedModel === EXPERIMENTAL_MODEL_NAME) ? personalitySelector.value : undefined;
chats[newChatId] = {
history: [],
model: selectedModel,
title: "New Chat", // Temporary title
personality: selectedPersonality
};
currentChatId = newChatId; // Set as active chat
chatIdForMessage = newChatId;
console.log(`Created new chat: ${currentChatId} with model ${selectedModel}, personality ${selectedPersonality || 'N/A'}`);
saveCurrentChatId();
saveAllChats();
renderChatList();
updateActiveChatListItem();

// If it wasn't the initial message (i.e., from New Chat button), need to init AI first
if (!isInitialMessage) {
await initializeAICurrentChat();
if (!currentChatSession) {
console.error("sendMessage: AI session failed to initialize for new chat.");
displayMessage("Failed to start the AI session. Please try again.", 'bot', true);
return; // Stop if init failed
}
}
// Display user message *after* potential init clears the screen
displayMessage(messageText, 'user');
addMessageToCurrentChatHistory('user', messageText); // Save user message (sets title)

} else {
// --- Message for Existing Chat ---
if (isRateLimited()) return; // Check rate limit
messageTimestamps.push(Date.now()); // Record timestamp

displayMessage(messageText, 'user');
addMessageToCurrentChatHistory('user', messageText); // Save user message
}
// --- End of handling user message ---


// --- Send to AI ---
if (!chatIdForMessage || !chats[chatIdForMessage] || !currentChatSession) {
console.error("sendMessageInternal: Invalid state before sending to AI.", { chatIdForMessage, chatExists: !!chats[chatIdForMessage], sessionExists: !!currentChatSession });
displayMessage("Cannot send message. AI session is not ready.", 'bot', true);
return;
}

// Disable input, show loading state
if (isInitialMessage) { initialMessageInput.value = ''; } else { messageInput.value = ''; }
messageInput.disabled = true;
sendButton.disabled = true;
sendButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
const typingIndicator = showTypingIndicator();

try {
console.log("Sending message to AI model...");
const result = await currentChatSession.sendMessage(messageText);
console.log("AI response received.");
removeTypingIndicator();

const response = result.response;
const responseText = response.text();

// Check for safety blocks or empty response
if (response.promptFeedback?.blockReason) {
console.warn(`AI response blocked. Reason: ${response.promptFeedback.blockReason}`);
displayMessage(`My response was blocked due to safety guidelines (${response.promptFeedback.blockReason}). Please rephrase or try a different topic.`, 'bot', true);
// Optionally save blocked status
// addMessageToCurrentChatHistory('model', `[Blocked: ${response.promptFeedback.blockReason}]`);
} else {
// Display and save the bot response (even if empty)
displayMessage(responseText, 'bot');
addMessageToCurrentChatHistory('model', responseText);
}

} catch (error) {
console.error("sendMessage API Error:", error);
removeTypingIndicator();
let errMsg = "Sorry, I encountered an error processing your request.";
if (error?.message) { errMsg += ` Details: ${error.message}`; }
displayMessage(errMsg, 'bot', true);
// Optionally save error status
// addMessageToCurrentChatHistory('model', `[Error: ${error.message || 'Unknown'}]`);
} finally {
// Re-enable input
messageInput.disabled = false;
sendButton.disabled = false;
sendButton.innerHTML = '<i class="fas fa-arrow-up"></i>';
messageInput.focus();
}
}

/** Wrapper for sending from the main chat input. */
function sendMessage() {
if (!messageInput || isInitializing) return;
sendMessageInternal(messageInput.value.trim(), false);
}

/** Wrapper for sending from the initial welcome screen input. */
async function handleInitialSendMessage() {
if (!initialMessageInput || !initialSendButton || isInitializing) return;
const messageText = initialMessageInput.value.trim();
if (!messageText) return;

// Create chat state first (as it's always a new chat)
const newChatId = generateChatId();
const selectedModel = loadSelectedModelPreference(); // Use global preference
const selectedPersonality = (selectedModel === EXPERIMENTAL_MODEL_NAME) ? DEFAULT_PERSONALITY : undefined;
chats[newChatId] = { history: [], model: selectedModel, title: "New Chat", personality: selectedPersonality };
currentChatId = newChatId;
console.log(`Created new chat from initial view: ${currentChatId}`);
saveCurrentChatId(); saveAllChats(); renderChatList(); updateActiveChatListItem();

// Switch UI and Initialize AI
switchToChatView();
await initializeAICurrentChat(); // Wait for AI initialization

if (!currentChatSession) {
console.error("handleInitialSendMessage: AI session failed to initialize.");
displayMessage("Failed to start the AI session. Check config/API Key.", 'bot', true);
messageInput.disabled = true; sendButton.disabled = true; // Keep disabled
sendButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
return; // Stop processing
}

// Now send the message using the internal function
await sendMessageInternal(messageText, true);
}


// --- Event Handlers ---

/**
* Handles selecting a chat from the sidebar.
* @param {string} chatId - The ID of the chat to select.
*/
function handleSelectChat(chatId) {
if (chatId === currentChatId || isInitializing) return; // Do nothing if already selected or AI is busy

console.log(`Selecting chat: ${chatId}`);
currentChatId = chatId;
saveCurrentChatId(); // Persist the selection
updateActiveChatListItem(); // Update sidebar UI
switchToChatView(); // Ensure chat view is visible
initializeAICurrentChat(); // Initialize AI for the selected chat
}

/** Handles clicking the "New Chat" button. */
function handleNewChat() {
console.log("New chat requested via button");
if (isInitializing) return; // Don't interrupt AI initialization

currentChatId = null; // Clear active chat ID
saveCurrentChatId();
currentChatSession = null; // Clear AI session

switchToChatView(); // Show the chat interface
chatMessagesContainer.innerHTML = ''; // Clear any previous messages
updateActiveChatListItem(); // Deactivate item in sidebar

// Reset input fields and buttons
messageInput.value = '';
messageInput.disabled = false;
messageInput.placeholder = "Message Graxybot..."; // Reset placeholder
sendButton.disabled = false;
sendButton.innerHTML = '<i class="fas fa-arrow-up"></i>';

// Set model selector to the global preference
const preferredModel = loadSelectedModelPreference();
modelSelector.value = preferredModel;

// Show/hide and set personality based on the preferred model
const showPersonality = preferredModel === EXPERIMENTAL_MODEL_NAME;
togglePersonalitySelector(showPersonality);
if (showPersonality) {
personalitySelector.value = DEFAULT_PERSONALITY; // Reset to default for new chat
}

messageInput.focus(); // Focus the input field
}

/**
* Handles deleting a chat after confirmation.
* @param {string} chatIdToDelete - The ID of the chat to delete.
*/
function handleDeleteChat(chatIdToDelete) {
if (!chats[chatIdToDelete] || isInitializing) return; // Can't delete non-existent chat or while AI is busy

// Confirmation dialog
const chatTitle = chats[chatIdToDelete].title || `Chat ${chatIdToDelete.substring(chatIdToDelete.length - 5)}`;
if (!confirm(`Are you sure you want to delete the chat "${chatTitle}"? This cannot be undone.`)) {
return; // User cancelled
}

console.log(`Deleting chat: ${chatIdToDelete}`);
const wasActive = (currentChatId === chatIdToDelete);
delete chats[chatIdToDelete]; // Remove from memory
saveAllChats(); // Update localStorage

// If the deleted chat was the active one, switch to a "new chat" state
if (wasActive) {
console.log("Deleted chat was active, switching to new chat state.");
handleNewChat(); // Go to the new chat screen/state
}

renderChatList(); // Refresh the sidebar list (which also updates active state if needed)
}

/** Handles changes to the Model Selector dropdown. */
function handleModelChange(event) {
const selectedModel = event.target.value;
console.log(`Model selected via UI: ${selectedModel}`);
saveSelectedModelPreference(selectedModel); // Save global preference

const showPersonality = selectedModel === EXPERIMENTAL_MODEL_NAME;
togglePersonalitySelector(showPersonality); // Show/hide personality selector

// If a chat is currently active, update its model and re-initialize
if (currentChatId && chats[currentChatId]) {
console.log(`Updating model for current chat ${currentChatId} to ${selectedModel}`);
chats[currentChatId].model = selectedModel;
// If switching TO experimental, set default personality.
// If switching FROM experimental, remove personality.
if (showPersonality) {
// Use current personality value if available, else default
chats[currentChatId].personality = personalitySelector.value || DEFAULT_PERSONALITY;
} else {
delete chats[currentChatId].personality; // Clean up personality if model doesn't support it
}
saveAllChats();
initializeAICurrentChat(); // Re-initialize with new model/personality settings
} else if (!currentChatId && chatView && !chatView.classList.contains('hidden')) {
// If on a "new chat" screen (no currentChatId but chat view visible)
// just update visibility and reset personality selector if needed.
// Personality will be set when first message is sent.
if (showPersonality) personalitySelector.value = DEFAULT_PERSONALITY;
}
// No action needed if on initial view, visibility is handled by togglePersonalitySelector
}

/** Handles changes to the Personality Selector dropdown. */
function handlePersonalityChange(event) {
const selectedPersonality = event.target.value;
console.log(`Personality selected: ${selectedPersonality}`);

// If a chat is active AND uses the experimental model, update its personality and re-initialize
if (currentChatId && chats[currentChatId] && chats[currentChatId].model === EXPERIMENTAL_MODEL_NAME) {
console.log(`Updating personality for current chat ${currentChatId} to ${selectedPersonality}`);
chats[currentChatId].personality = selectedPersonality;
saveAllChats();
initializeAICurrentChat(); // Re-initialize with the new personality prompt
}
// No action needed if no chat is active or the active chat doesn't use the experimental model
}


// --- Initialization Sequence ---
document.addEventListener('DOMContentLoaded', () => {
console.log("DOM Loaded. Initializing Graxybot UI...");

// Get references to all required DOM elements
chatMessagesContainer = document.getElementById('chat-messages');
messageInput = document.getElementById('message-input');
sendButton = document.getElementById('send-button');
rateLimitMessageDiv = document.getElementById('rate-limit-message');
modelSelector = document.getElementById('model-selector');
initialView = document.getElementById('initial-view');
chatView = document.getElementById('chat-view');
initialMessageInput = document.getElementById('initial-message-input');
initialSendButton = document.getElementById('initial-send-button');
sidebar = document.querySelector('.sidebar');
newChatBtn = document.getElementById('new-chat-btn');
chatListUl = document.getElementById('chat-list');
personalitySelectorContainer = document.getElementById('personality-selector-container');
personalitySelector = document.getElementById('personality-selector');

// Validate that all essential elements were found
const essentialElements = { chatMessagesContainer, messageInput, sendButton, rateLimitMessageDiv, modelSelector, initialView, chatView, initialMessageInput, initialSendButton, sidebar, newChatBtn, chatListUl, personalitySelectorContainer, personalitySelector };
let missingElement = false;
for (const key in essentialElements) {
if (!essentialElements[key]) {
console.error(`Fatal Error: UI element not found: ${key}`);
missingElement = true;
}
}
if (missingElement) {
document.body.innerHTML = "<p style='color: red; padding: 20px; font-family: sans-serif;'>Error: Chat interface failed to load completely. Essential elements are missing. Check the console for details.</p>";
return; // Stop initialization
}
console.log("All essential DOM elements found.");

// Load data from localStorage
chats = loadAllChats();
currentChatId = loadCurrentChatId(); // Get ID, but don't assume chat exists yet
const preferredModel = loadSelectedModelPreference(); // Load user's preferred model

// Set the model selector's initial value
modelSelector.value = preferredModel;

// Render the chat list in the sidebar
renderChatList();

// Check for API Key and handle initial state
if (!API_KEY || API_KEY === "YOUR_API_KEY") {
console.warn("API Key is missing or not configured in the script.");
const warningMsg = "Welcome! Please configure your API Key in the script (`API_KEY` variable) to enable the chat.";
// Display warning and disable functionality
if(initialView && !initialView.classList.contains('hidden')) {
initialMessageInput.placeholder = "API Key needed in script!";
} else if (chatMessagesContainer) {
displayMessage(warningMsg, 'bot', true);
}
// Disable inputs and controls
messageInput.disabled = true; sendButton.disabled = true;
initialMessageInput.disabled = true; initialSendButton.disabled = true;
modelSelector.disabled = true; personalitySelector.disabled = true;
newChatBtn.disabled = true;
// Show initial view if no valid chat is loaded
if (!currentChatId || !chats[currentChatId]) {
switchToInitialView();
} else {
// If a valid chat exists, show it but indicate the API key issue
switchToChatView();
// Attempt init - it will fail and display the API key error message
initializeAICurrentChat();
}
} else {
// API Key found, proceed with normal initialization
console.log("API Key found. Proceeding with initialization.");
if (currentChatId && chats[currentChatId]) {
// If a valid chat ID was loaded and the chat exists, restore it
console.log(`Restoring active chat: ${currentChatId}`);
switchToChatView();
initializeAICurrentChat(); // Initialize AI for the restored chat
} else {
// No valid active chat found, show the initial welcome screen
console.log("No active chat found or chat data missing. Showing initial view.");
switchToInitialView(); // This also sets initial selector states
initialMessageInput.focus();
}
}

// --- Attach Event Listeners ---
console.log("Attaching event listeners...");

// Send button in chat view
sendButton.addEventListener('click', sendMessage);
// Enter key in chat input (ignore shift+enter for newlines)
messageInput.addEventListener('keypress', (event) => {
if (event.key === 'Enter' && !event.shiftKey && !sendButton?.disabled) {
event.preventDefault(); // Prevent default newline insertion
sendMessage();
}
});

// Send button on initial screen
initialSendButton.addEventListener('click', handleInitialSendMessage);
// Enter key in initial input
initialMessageInput.addEventListener('keypress', (event) => {
if (event.key === 'Enter' && !event.shiftKey && !initialSendButton?.disabled) {
event.preventDefault();
handleInitialSendMessage();
}
});

// Model selector change
modelSelector.addEventListener('change', handleModelChange);

// Personality selector change
personalitySelector.addEventListener('change', handlePersonalityChange);

// New chat button
newChatBtn.addEventListener('click', handleNewChat);

console.log("Event listeners attached. Initialization complete.");
});

</script>

</body>
</html>
